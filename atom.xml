<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子墨不语</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.molingyu.com/"/>
  <updated>2017-09-25T19:46:05.400Z</updated>
  <id>http://www.molingyu.com/</id>
  
  <author>
    <name>子墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android启动源码阅读(一)init进程的启动</title>
    <link href="http://www.molingyu.com/2017/09/26/Android%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)init%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
    <id>http://www.molingyu.com/2017/09/26/Android启动源码阅读(一)init进程的启动/</id>
    <published>2017-09-25T19:46:05.400Z</published>
    <updated>2017-09-25T19:46:05.400Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统中，Kernel启动完毕之后，启动的第一个用户空间的进程，就是名为<strong>init</strong>的进程：</p><p>以下是查找init进程源码的过程：</p><ol><li><p>查找init进程mk文件位置：</p><p>查找可执行程序：init的编译MODULE定义，即全局查找字符串: LOCAL_MODULE:= init，从而找到mk文件位置system/core/init/Android.mk</p></li><li><p>从MODULE的LOCAL_SRC_FILES找到init.cpp文件</p></li><li><p>全局查找文件(按两次)init.cpp，从而最终找到init.cpp的源码system/core/init/init.cpp</p></li></ol><h1 id="init启动解析-main函数"><a href="#init启动解析-main函数" class="headerlink" title="init启动解析: main函数"></a>init启动解析: main函数</h1><p>作为init可执行文件的入口init.cpp-&gt;main()，我们来看下它是怎么执行的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 将/usr/bin:/bin加入到环境变量中去</span></div><div class="line">    add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--second-stage"</span>) != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></div><div class="line">    <span class="comment">// on / and then we'll let the rc file figure out the rest.</span></div><div class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</div><div class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</div><div class="line">        mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</div><div class="line">        mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</div><div class="line">        mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></div><div class="line">        mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</div><div class="line">        mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.</span></div><div class="line">    selinux_initialize(is_first_stage);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// These directories were necessarily created before initial policy load</span></div><div class="line">    <span class="comment">// and therefore need their security context restored to the proper value.</span></div><div class="line">    <span class="comment">// This must happen before /dev is populated by ueventd.</span></div><div class="line">    NOTICE(<span class="string">"Running restorecon...\n"</span>);</div><div class="line">    restorecon(<span class="string">"/dev"</span>);</div><div class="line">    restorecon(<span class="string">"/dev/socket"</span>);</div><div class="line">    restorecon(<span class="string">"/dev/__properties__"</span>);</div><div class="line">    restorecon(<span class="string">"/property_contexts"</span>);</div><div class="line">    restorecon_recursive(<span class="string">"/sys"</span>);</div><div class="line"></div><div class="line">    epoll_fd = epoll_create1(EPOLL_CLOEXEC);</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//信号处理handler初始化：通过信号量，管理init fork出来的子进程</span></div><div class="line">    signal_handler_init();</div><div class="line">    <span class="comment">//导入默认boot_property</span></div><div class="line">    property_load_boot_defaults();</div><div class="line">    <span class="comment">//导入oem锁状态</span></div><div class="line">    export_oem_lock_status();</div><div class="line">    <span class="comment">//属性服务初始化</span></div><div class="line">    start_property_service();</div><div class="line">    </div><div class="line">    <span class="comment">//创建内建的函数映射key-func的map集合，Action解析触发都依赖与该map查找对应的函数</span></div><div class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</div><div class="line">    Action::set_function_map(&amp;function_map);</div><div class="line"></div><div class="line">    <span class="comment">//init.rc文件的解析</span></div><div class="line">    Parser&amp; parser = Parser::GetInstance();</div><div class="line">    parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</div><div class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</div><div class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</div><div class="line">    <span class="comment">//开始解析</span></div><div class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</div><div class="line"></div><div class="line">    ActionManager&amp; am = ActionManager::GetInstance();</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// init进程进入该循环</span></div><div class="line">    <span class="comment">// 1. 执行am的命令</span></div><div class="line">    <span class="comment">// 2. 重启相关的process，这里其实是我们通过service启动的子进程</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!waiting_for_exec) &#123;</div><div class="line">            am.ExecuteOneCommand();</div><div class="line">            restart_processes();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> timeout = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span> (process_needs_restart) &#123;</div><div class="line">            timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</div><div class="line">            <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</div><div class="line">                timeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</div><div class="line">            timeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bootchart_sample(&amp;timeout);</div><div class="line">        <span class="comment">//阻塞，等待新的command的到来</span></div><div class="line">        epoll_event ev;</div><div class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</div><div class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</div><div class="line">            ERROR(<span class="string">"epoll_wait failed: %s\n"</span>, strerror(errno));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</div><div class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>总结下来，init进程做了几件事情：</p><ol><li>bin环境变量的添加</li><li>所需的文件系统的挂载</li><li>信号处理、oem锁、属性服务启动</li><li>init.rc文件的解析</li><li>进入循环，通过ActionManager开始执行Command</li><li>restart_processes，重新启动process，如果有必要的话</li></ol><p>本文，我们只关注两点：</p><ol><li>rc文件的解析</li><li>restart_processes 启动新的process</li></ol><h2 id="init-rc文件的解析过程"><a href="#init-rc文件的解析过程" class="headerlink" title="init.rc文件的解析过程"></a>init.rc文件的解析过程</h2><p>init.rc文件位于system/core/rootdir/init.rc</p><h3 id="rc文件的变化"><a href="#rc文件的变化" class="headerlink" title="rc文件的变化"></a>rc文件的变化</h3><p>在 7.+ 版本的系统中，rc文件的内容根据具体的模块拆分成不同的rc文件，</p><p>比如init.rc文件的头部:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import /init.environ.rc</div><div class="line">import /init.usb.rc</div><div class="line">import /init.$&#123;ro.hardware&#125;.rc</div><div class="line">import /init.usb.configfs.rc</div><div class="line">import /init.$&#123;ro.zygote&#125;.rc</div></pre></td></tr></table></figure></p><p>又比如servicemanager的初始化： frameworks/native/cmds/servicemanager/servicemanager.rc</p><p>参考链接：<a href="http://blog.csdn.net/sunao2002002/article/details/52454878" target="_blank" rel="external">http://blog.csdn.net/sunao2002002/article/details/52454878</a></p><h3 id="解析源码段分析"><a href="#解析源码段分析" class="headerlink" title="解析源码段分析"></a>解析源码段分析</h3><p>先来看看代码段<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Parser&amp; parser = Parser::GetInstance();</div><div class="line">parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</div><div class="line">parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</div><div class="line">parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</div><div class="line">parser.ParseConfig(<span class="string">"/init.rc"</span>);</div></pre></td></tr></table></figure></p><ol><li><p>Parser是一个单例，全局字符串查找 Parser::GetInstance，即可找到定义位置system/core/init/init_parser.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Parser&amp; Parser::GetInstance() &#123;</div><div class="line">    <span class="keyword">static</span> Parser instance;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用AddSectionParser将几个解析器放置到map中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parser::AddSectionParser(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</div><div class="line">                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SectionParser&gt; parser) &#123;</div><div class="line">    section_parsers_[name] = <span class="built_in">std</span>::move(parser);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>开始解析:<code>parser.ParseConfig(&quot;/init.rc&quot;);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Parser::ParseConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</div><div class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</div><div class="line">        <span class="keyword">return</span> ParseConfigDir(path);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ParseConfigFile(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>由于传入的”/init.rc”是一个文件，因此开始<code>ParseConfigFile(path)</code>解析</p><ol><li>file解析<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Parser::ParseConfigFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</div><div class="line">    INFO(<span class="string">"Parsing file %s...\n"</span>, path.c_str());</div><div class="line">    Timer t;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data;</div><div class="line">    <span class="comment">//将file内容读入data字符串中</span></div><div class="line">    <span class="keyword">if</span> (!read_file(path.c_str(), &amp;data)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//内容字符串修正</span></div><div class="line">    data.push_back(<span class="string">'\n'</span>); <span class="comment">// <span class="doctag">TODO:</span> fix parse_config.</span></div><div class="line">    <span class="comment">//4.1 解析文件内容</span></div><div class="line">    ParseData(path, data);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sp : section_parsers_) &#123;</div><div class="line">        <span class="comment">//4.2 解析文件完毕</span></div><div class="line">        sp.second-&gt;EndFile(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Turning this on and letting the INFO logging be discarded adds 0.2s to</span></div><div class="line">    <span class="comment">// Nexus 9 boot time, so it's disabled by default.</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) DumpState();</div><div class="line"></div><div class="line">    NOTICE(<span class="string">"(Parsing %s took %.2fs.)\n"</span>, path.c_str(), t.duration());</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="ParseData-解析说明"><a href="#ParseData-解析说明" class="headerlink" title="ParseData()解析说明"></a>ParseData()解析说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parser::ParseData(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data) &#123;</div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span> Use a parser with const input and remove this copy</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; data_copy(data.begin(), data.end());</div><div class="line">    data_copy.push_back(<span class="string">'\0'</span>);</div><div class="line">    <span class="comment">//初始化解析参数</span></div><div class="line">    parse_state state;</div><div class="line">    state.filename = filename.c_str();</div><div class="line">    state.line = <span class="number">0</span>;</div><div class="line">    state.ptr = &amp;data_copy[<span class="number">0</span>];</div><div class="line">    state.nexttoken = <span class="number">0</span>;</div><div class="line">    <span class="comment">//解析器</span></div><div class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</div><div class="line">    <span class="comment">//解析出来的参数存放位置</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">//next_token()：真正解析文件的地方</span></div><div class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</div><div class="line">        <span class="keyword">case</span> T_EOF:</div><div class="line">            <span class="comment">//解析到文件末尾</span></div><div class="line">            <span class="keyword">if</span> (section_parser) &#123;</div><div class="line">                section_parser-&gt;EndSection();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> T_NEWLINE:</div><div class="line">            <span class="comment">//新行</span></div><div class="line">            state.line++;</div><div class="line">            <span class="keyword">if</span> (args.empty()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</div><div class="line">                <span class="comment">//新的一行开始，如果此前的section_parser不为空，则结束那一行的解析：EndSection</span></div><div class="line">                <span class="keyword">if</span> (section_parser) &#123;</div><div class="line">                    section_parser-&gt;EndSection();</div><div class="line">                &#125;</div><div class="line">                section_parser = section_parsers_[args[<span class="number">0</span>]].get();</div><div class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</div><div class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123;</div><div class="line">                    parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</div><div class="line">                    section_parser = <span class="literal">nullptr</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</div><div class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</div><div class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseLineSection(args, state.filename,</div><div class="line">                                                      state.line, &amp;ret_err)) &#123;</div><div class="line">                    parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            args.clear();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> T_TEXT:</div><div class="line">            <span class="comment">//解析到字符串内容：例如 service zygote /system/bin/app_process</span></div><div class="line">            <span class="comment">//则解析到的结果是args=&#123;"service", "zygote", "/system/bin/app_process"&#125;</span></div><div class="line">            args.emplace_back(state.text);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>GetInstance</p><h3 id="举例说明解析过程"><a href="#举例说明解析过程" class="headerlink" title="举例说明解析过程"></a>举例说明解析过程</h3><ol><li>读取init.rc文件时，遇到import语句，因此args[0] = “import”，采用ImportParser进行解析</li><li><p>调用ImportParser-&gt;ParseSection进行解析：args={“import”, “/init.${ro.zygote}.rc”}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> ImportParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</div><div class="line">                                <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</div><div class="line">    <span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</div><div class="line">        *err = <span class="string">"single argument needed for import\n"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> conf_file;</div><div class="line">    <span class="comment">//通过expand_props将$&#123;ro.zygote&#125;替换成对应平台的实现，例如zygote32，因此文件名为：init.zygote32.rc</span></div><div class="line">    <span class="keyword">bool</span> ret = expand_props(args[<span class="number">1</span>], &amp;conf_file);</div><div class="line">    <span class="keyword">if</span> (!ret) &#123;</div><div class="line">        *err = <span class="string">"error while expanding import"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INFO(<span class="string">"Added '%s' to import list\n"</span>, conf_file.c_str());</div><div class="line">    <span class="comment">//将解析出来，import的真正文件名放到imports_列表中</span></div><div class="line">    imports_.emplace_back(<span class="built_in">std</span>::move(conf_file));</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>回到Parser::ParseConfigFile，当文件解析完毕之后，调用所有的Parser-&gt;EndFile</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sp : section_parsers_) &#123;</div><div class="line">    <span class="comment">//4.2 解析文件完毕</span></div><div class="line">    sp.second-&gt;EndFile(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>因此，我们看下ImportParser-&gt;EndFile():<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ImportParser::EndFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename) &#123;</div><div class="line">    <span class="keyword">auto</span> current_imports = <span class="built_in">std</span>::move(imports_);</div><div class="line">    imports_.clear();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : current_imports) &#123;</div><div class="line">        <span class="keyword">if</span> (!Parser::GetInstance().ParseConfig(s)) &#123;</div><div class="line">            ERROR(<span class="string">"could not import file '%s' from '%s': %s\n"</span>,</div><div class="line">                  s.c_str(), filename.c_str(), strerror(errno));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由此可见，又针对每个文件，进行了Parser::GetInstance().ParseConfig(s)解析</p><ol><li><p>imprt进来的file的解析步骤仍然走的：</p><ul><li>Parser::ParseConfig</li><li>Parser::ParseConfigFile</li><li>循环1. Parser::ParseData</li><li>循环2. system/core/init/parser.cpp-&gt;next_token()</li><li>循环3. Parser::ParseSection</li><li>循环4. Parser::EndSection</li></ul></li><li><p>我们来看service的解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</div><div class="line">    class main</div><div class="line">    socket zygote stream 660 root system</div><div class="line">    onrestart write /sys/android_power/request_state wake</div><div class="line">    onrestart write /sys/power/state on</div><div class="line">    onrestart restart audioserver</div><div class="line">    onrestart restart cameraserver</div><div class="line">    onrestart restart media</div><div class="line">    onrestart restart netd</div><div class="line">    writepid /dev/cpuset/foreground/tasks</div></pre></td></tr></table></figure><ol><li>在ParserData()的时候，args[0]=”service”，采用ServiceParser进行解析<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> ServiceParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</div><div class="line">                                 <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</div><div class="line">    <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</div><div class="line">        *err = <span class="string">"services must have a name and a program"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span> (!IsValidName(name)) &#123;</div><div class="line">        *err = StringPrintf(<span class="string">"invalid service name '%s'"</span>, name.c_str());</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str_args(args.begin() + <span class="number">2</span>, args.end());</div><div class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, <span class="string">"default"</span>, str_args);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>由此可见，service关键字的解析，将会创建Service对象，并赋值给ServiceParser的service_成员</p><ol><li>当这一行解析完毕之后，进入下一行，由于下一行的args[0]不为{“service”，”on”,”import”}中的任意一个，因此进入解析方法ParseLineSection <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> ServiceParser::ParseLineSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line, <span class="built_in">std</span>::<span class="built_in">string</span>* err) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> service_ ? service_-&gt;HandleLine(args, err) : <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>HandleLine方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Service::HandleLine(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</div><div class="line">    <span class="keyword">if</span> (args.empty()) &#123;</div><div class="line">        *err = <span class="string">"option needed, but not provided"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据OptionHandlerMap,找寻args[0]所对应的函数</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> OptionHandlerMap handler_map;</div><div class="line">    <span class="keyword">auto</span> handler = handler_map.FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!handler) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//找到args[0]对应的方法，调用该方法，并将方法的返回值true/false，</span></div><div class="line">    <span class="comment">//返回: 这些方法基本上都是service_的属性设置，返回的都是boolean值</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*handler)(args, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>//OptionHandlerMap定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map option_handlers = &#123;</div><div class="line">        &#123;<span class="string">"class"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleClass&#125;&#125;,</div><div class="line">        &#123;<span class="string">"console"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleConsole&#125;&#125;,</div><div class="line">        &#123;<span class="string">"critical"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleCritical&#125;&#125;,</div><div class="line">        &#123;<span class="string">"disabled"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleDisabled&#125;&#125;,</div><div class="line">        &#123;<span class="string">"group"</span>,       &#123;<span class="number">1</span>,     NR_SVC_SUPP_GIDS + <span class="number">1</span>, &amp;Service::HandleGroup&#125;&#125;,</div><div class="line">        &#123;<span class="string">"ioprio"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleIoprio&#125;&#125;,</div><div class="line">        &#123;<span class="string">"keycodes"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleKeycodes&#125;&#125;,</div><div class="line">        &#123;<span class="string">"oneshot"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleOneshot&#125;&#125;,</div><div class="line">        &#123;<span class="string">"onrestart"</span>,   &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleOnrestart&#125;&#125;,</div><div class="line">        &#123;<span class="string">"seclabel"</span>,    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleSeclabel&#125;&#125;,</div><div class="line">        &#123;<span class="string">"setenv"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleSetenv&#125;&#125;,</div><div class="line">        &#123;<span class="string">"socket"</span>,      &#123;<span class="number">3</span>,     <span class="number">6</span>,    &amp;Service::HandleSocket&#125;&#125;,</div><div class="line">        &#123;<span class="string">"user"</span>,        &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleUser&#125;&#125;,</div><div class="line">        &#123;<span class="string">"writepid"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleWritepid&#125;&#125;,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> option_handlers;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>当所有的Line解析完毕，到达文件末尾，则调用ServiceParser::EndSection方法:<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ServiceParser::EndSection() &#123;</div><div class="line">    <span class="keyword">if</span> (service_) &#123;</div><div class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>将刚才解析的service_成员,move到ServiceManager的列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ServiceManager::AddService(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Service&gt; service) &#123;</div><div class="line">    Service* old_service = FindServiceByName(service-&gt;name());</div><div class="line">    <span class="keyword">if</span> (old_service) &#123;</div><div class="line">        ERROR(<span class="string">"ignored duplicate definition of service '%s'"</span>,</div><div class="line">              service-&gt;name().c_str());</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    services_.emplace_back(<span class="built_in">std</span>::move(service));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>至此，init.zygote32.rc文件解析完毕</li></ol></li></ol><h3 id="restart-processes"><a href="#restart-processes" class="headerlink" title="restart_processes"></a>restart_processes</h3><p>前面分析init.cpp-&gt;main()函数的时候，在while循环中，调用了restart_processes方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_processes</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    process_needs_restart = <span class="number">0</span>;</div><div class="line">    ServiceManager::GetInstance().</div><div class="line">        ForEachServiceWithFlags(SVC_RESTARTING, [] (Service* s) &#123;</div><div class="line">                s-&gt;RestartIfNeeded(process_needs_restart);</div><div class="line">            &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> ServiceManager::ForEachServiceWithFlags(<span class="keyword">unsigned</span> matchflags,</div><div class="line">                                             <span class="keyword">void</span> (*func)(Service* svc)) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : services_) &#123;</div><div class="line">        <span class="keyword">if</span> (s-&gt;flags() &amp; matchflags) &#123;</div><div class="line">            func(s.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从代码看到，这段代码对每一个Service，都进行了调用函数调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">：s-&gt;RestartIfNeeded(process_needs_restart);</div></pre></td></tr></table></figure></p><p>因此，最终调用到了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Service::RestartIfNeeded(<span class="keyword">time_t</span>&amp; process_needs_restart) &#123;</div><div class="line">    <span class="keyword">time_t</span> next_start_time = time_started_ + <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next_start_time &lt;= gettime()) &#123;</div><div class="line">        flags_ &amp;= (~SVC_RESTARTING);</div><div class="line">        Start();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((next_start_time &lt; process_needs_restart) ||</div><div class="line">        (process_needs_restart == <span class="number">0</span>)) &#123;</div><div class="line">        process_needs_restart = next_start_time;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="调用到了Service-Start-方法-system-core-init-service-cpp"><a href="#调用到了Service-Start-方法-system-core-init-service-cpp" class="headerlink" title="调用到了Service:Start()方法: system/core/init/service.cpp"></a>调用到了Service:Start()方法: system/core/init/service.cpp</h3><p>这段代码比较长，就不贴了，列举几个重要的片段：</p><ul><li><p>fork一个新的进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pid_t</span> pid = fork();</div></pre></td></tr></table></figure></li><li><p>在新的进程中，如果sockets_不为空，就创建socket:  此处init.zygote32.rc文件中，socket zygote stream 660 root system</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; si : sockets_) &#123;</div><div class="line">    <span class="keyword">int</span> socket_type = ((si.type == <span class="string">"stream"</span> ? SOCK_STREAM :</div><div class="line">                        (si.type == <span class="string">"dgram"</span> ? SOCK_DGRAM :</div><div class="line">                         SOCK_SEQPACKET)));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* socketcon =</div><div class="line">        !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> s = create_socket(si.name.c_str(), socket_type, si.perm,</div><div class="line">                          si.uid, si.gid, socketcon);</div><div class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//调用PublishSocket，将si.name=zygote，设置到环境变量"ANDROID_SOCKET_ENV_PREFIX si.name"中去</span></div><div class="line">        PublishSocket(si.name, s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Service::PublishSocket(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> fd) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = StringPrintf(ANDROID_SOCKET_ENV_PREFIX <span class="string">"%s"</span>, name.c_str());</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> val = StringPrintf(<span class="string">"%d"</span>, fd);</div><div class="line">    add_environment(key.c_str(), val.c_str());</div><div class="line"></div><div class="line">    <span class="comment">/* make sure we don't close-on-exec */</span></div><div class="line">    fcntl(fd, F_SETFD, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此会创建一个名为zygote的socket，挂在在/dev/socket/zygote节点下</p><p>至此，一个service进程就解析，并创建完毕了</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>上述分析，仅仅针对service关键字做了分析，其他的关键字on、class等等，同理分析</p><p>参考资料:</p><ul><li><a href="http://blog.csdn.net/A8316124/article/details/62224237" target="_blank" rel="external">http://blog.csdn.net/A8316124/article/details/62224237</a></li><li><a href="http://blog.csdn.net/sunao2002002/article/details/52454878" target="_blank" rel="external">http://blog.csdn.net/sunao2002002/article/details/52454878</a></li><li>system/core/init/readme.txt</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux系统中，Kernel启动完毕之后，启动的第一个用户空间的进程，就是名为&lt;strong&gt;init&lt;/strong&gt;的进程：&lt;/p&gt;
&lt;p&gt;以下是查找init进程源码的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查找init进程mk文件位置：&lt;/p&gt;
&lt;p&gt;查找可执行程
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://www.molingyu.com/tags/Android/"/>
    
      <category term="源码阅读" scheme="http://www.molingyu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android源码阅读准备</title>
    <link href="http://www.molingyu.com/2017/09/25/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.molingyu.com/2017/09/25/Android源码阅读技巧/</id>
    <published>2017-09-25T14:34:15.387Z</published>
    <updated>2017-09-25T14:34:15.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>参考<a href="https://source.android.com/source/downloading" target="_blank" rel="external">官方doc</a>，需要自备梯子</p><h2 id="选定分支"><a href="#选定分支" class="headerlink" title="选定分支"></a>选定分支</h2><p>我自己的是Nexus6，写这篇日志时，当前官网适配的最新版本是 7.1.1_r45，因此我的源码编译和阅读都是基于这个分支，手机上也是运行的这个版本。</p><h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><ul><li><strong>Windows</strong> : Source Insight，跟踪代码的一大利器</li><li><strong>Linux</strong> : wine + Source Insight，各种问题，够折腾</li><li><strong>Linux</strong> : AndroidStudio，各种java索引跳转溜溜的，除了native代码</li></ul><p>因此，我采用了<a href="http://blog.csdn.net/yanbober/article/details/48846331" target="_blank" rel="external"><strong>AndroidStudio导入Android源码</strong></a>的方式来浏览源码</p><p>这样唯一一个问题就是native代码的阅读，需要自己手动全局查找:</p><blockquote><p>1.查找某个类：Ctrl + Shift + F，然后输入类名称，比如查找native的Looper类，可以通过全局搜索” Looper {“，来定位到类定义位置。</p><p>2.查找某个方法: Ctrl + Shift + F， </p><ul><li>方法名</li><li>方法名 + {</li><li>正则表达式：” “ + 方法名 + [(] (.*) [)] + [\n] + [{]</li><li>某个类中的某个方法，直接搜: “ “ + 方法名 + “(“</li><li>有些方法是类定义的C++方法，可以采用:  “::” + 方法名， 的方式来搜索</li></ul><p>3.查找某个文件: Ctrl + Shift + N（或者按两次）, 输入文件名，如果有多个匹配，需要谨慎选择，通常情况下都是优先匹配到的第一个文件。</p></blockquote><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>如此，我们就可以遨游在AndroidSource的海洋里了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://source.android.com/source/downloading" target="_blank" rel="external">https://source.android.com/source/downloading</a><br><a href="http://blog.csdn.net/yanbober/article/details/48846331" target="_blank" rel="external">http://blog.csdn.net/yanbober/article/details/48846331</a><br><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="external">http://www.runoob.com/regexp/regexp-syntax.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码下载&quot;&gt;&lt;a href=&quot;#源码下载&quot; class=&quot;headerlink&quot; title=&quot;源码下载&quot;&gt;&lt;/a&gt;源码下载&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://source.android.com/source/downloading&quot; targ
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://www.molingyu.com/tags/Android/"/>
    
      <category term="源码阅读" scheme="http://www.molingyu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>一个epoll实例</title>
    <link href="http://www.molingyu.com/2017/09/18/%E4%B8%80%E4%B8%AAepoll%E5%AE%9E%E4%BE%8B/"/>
    <id>http://www.molingyu.com/2017/09/18/一个epoll实例/</id>
    <published>2017-09-18T06:07:49.490Z</published>
    <updated>2017-09-18T06:07:49.490Z</updated>
    
    <content type="html"><![CDATA[<p>epoll 于Linux 2.5.44引入，旨在替换select和poll系统函数。</p><p>相对于select和poll来说，epoll更加灵活高效:</p><ul><li>没有监视描述符数量单进程1024限制</li><li>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</li></ul><h2 id="epoll在Android中的应用"><a href="#epoll在Android中的应用" class="headerlink" title="epoll在Android中的应用"></a>epoll在Android中的应用</h2><p>epoll机制在Android系统中扮演着一个很重要的角色，</p><ol><li>在MessageQueue的队列中，当队列为空时需要阻塞Looper线程，队列非空时候需要唤醒线程，使用到了epoll + eventfd(比pipe更高效的事件驱动，在<a href="https://android.googlesource.com/platform/system/core/+/8892ce6%5E!/" target="_blank" rel="external">6.0引入</a>)机制，高效的管理着消息队列</li><li>java NIO中 Selector采用了epoll机制实现SocketChannel管道事件轮询</li></ol><h2 id="实例代码（采用epoll-pipe实现）"><a href="#实例代码（采用epoll-pipe实现）" class="headerlink" title="实例代码（采用epoll + pipe实现）"></a>实例代码（采用epoll + pipe实现）</h2><p>本例我们采用 epoll + pipe的机制，简单的模拟一个通信唤醒的场景来理解epoll通信，更深入的理解，可以阅读libevent源码</p><ol><li>创建管道</li><li>创建epll事件：并设置关注的事件类型</li><li>创建epoll</li><li>往epoll注册事件</li><li>fork一个子进程，sleep(3)秒后，往管道写入数据</li><li>父进程挂起，监听事件源(管道读取端fd)事件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//最大事件数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXEVENTS = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 1. 创建管道，并将管道两端的fd存放在数组pipe_fd中</span></div><div class="line"><span class="comment">     * pipe_fd[0] ： 管道输出端，可读取fd</span></div><div class="line"><span class="comment">     * pipe_fd[1] ： 管道输入端，可写入fd</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">if</span> ((ret = pipe(pipe_fd)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"create pipe fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 2. 创建epoll关注事件源的事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></div><div class="line">    <span class="comment">//设置监听事件源</span></div><div class="line">    ev.data.fd = pipe_fd[<span class="number">0</span>];</div><div class="line">    <span class="comment">//设置监听什么事件：EPOLLIN, 事件源可读事件， EPOLLET 边缘触发模式(Edge Triggered)</span></div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 3. 创建epoll对象，返回epoll对象的fd地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(MAXEVENTS);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 4. 往epoll对象中 添加/修改/删除 一个事件(事件源fd, 事件类型&amp;ev)</span></div><div class="line"><span class="comment">     * EPOLL_CTL_ADD：注册新的fd到epfd中；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_DEL：从epfd中删除一个fd；</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev);</div><div class="line">    <span class="comment">//校验</span></div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_ctl fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fork一个进程，来读取epoll事件</span></div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></div><div class="line">        <span class="comment">//监听事件数组</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 6. 使用epoll，开始监听事件，并将事件放置到数组events中</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * epoll_wait会阻塞当前线程，当监听的事件发生的时候，会唤醒该线程</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">int</span> count = epoll_wait(epfd, events, MAXEVENTS, <span class="number">5000</span>);</div><div class="line">        <span class="keyword">char</span> r_buf[<span class="number">100</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="comment">//校验</span></div><div class="line">            <span class="keyword">if</span> ((events[i].data.fd == pipe_fd[<span class="number">0</span>]) &amp;&amp; (events[<span class="number">0</span>].events &amp; EPOLLIN)) &#123;</div><div class="line">                <span class="keyword">int</span> r_num = read(pipe_fd[<span class="number">0</span>], r_buf, <span class="number">100</span>);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"parrent read num is %d bytes data from the pipe, value is %d \n"</span>, r_num, atoi(r_buf));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent close read fd[0], wirte fd[1] and epfd over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//子进程</span></div><div class="line">        <span class="comment">//子进程不进行读取操作，关闭读取fd</span></div><div class="line">        close(pipe_fd[<span class="number">0</span>]);<span class="comment">//read</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sub does't read, so close read fd[0], over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">        <span class="comment">//当前线程睡眠3秒</span></div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 5. 子进程开始向管道写入数据，触发EPOLLIN事件</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">char</span> w_buf[<span class="number">100</span>];</div><div class="line">        <span class="built_in">strcpy</span>(w_buf, <span class="string">"1234"</span>);</div><div class="line">        <span class="keyword">if</span> (write(pipe_fd[<span class="number">1</span>], w_buf, <span class="number">5</span>) != <span class="number">-1</span>)<span class="comment">//you can remove this line for learn</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"sub write write num 1234, over \n"</span>);</div><div class="line">        <span class="comment">//关闭写入端管道fd</span></div><div class="line">        close(pipe_fd[<span class="number">1</span>]);<span class="comment">//write</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub close write fd[1] over \n"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//pid&lt;0, fork error</span></div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error:"</span> &lt;&lt; pid &lt;&lt; <span class="string">", close fds over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="改用epoll-eventfd来实现"><a href="#改用epoll-eventfd来实现" class="headerlink" title="改用epoll + eventfd来实现"></a>改用epoll + eventfd来实现</h2><p>eventfd在2.6.22引入，是比pipe更高效的线程间事件通知机制，它的缓冲区只有8个字节。</p><p>eventfd 只能用于线程间、父子进程间的通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Created by milo on 17-9-18.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXEVENTS = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * eventfd (unsigned int __count, int __flags)</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * man: http://man7.org/linux/man-pages/man2/eventfd.2.html</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * initval: eventfd设备初始值</span></div><div class="line"><span class="comment">     * flags: 在2.6.26之前的版本，必须设置为0，之后的版本有以下值：</span></div><div class="line"><span class="comment">     *     EFD_SEMAPHORE</span></div><div class="line"><span class="comment">     *     EFD_CLOEXEC</span></div><div class="line"><span class="comment">     *     EFD_NONBLOCK</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 1. 创建epoll关注事件源的事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></div><div class="line">    <span class="comment">//设置监听事件源</span></div><div class="line">    ev.data.fd = efd;</div><div class="line">    <span class="comment">//设置监听什么事件：EPOLLIN, 事件源可读事件， EPOLLET 边缘触发模式(Edge Triggered)</span></div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 2. 创建epoll对象，返回epoll对象的fd地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(MAXEVENTS);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 3. 往epoll对象中 添加/修改/删除 一个事件(事件源fd, 事件类型&amp;ev)</span></div><div class="line"><span class="comment">     * EPOLL_CTL_ADD：注册新的fd到epfd中；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_DEL：从epfd中删除一个fd；</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, efd, &amp;ev);</div><div class="line">    <span class="comment">//校验</span></div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_ctl fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fork一个进程，来读取epoll事件</span></div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></div><div class="line">        <span class="comment">//监听事件数组</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 4. 使用epoll，开始监听事件源，并将事件放置到数组events中</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * epoll_wait会阻塞当前线程，当监听的事件发生的时候，会唤醒该线程</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">int</span> count = epoll_wait(epfd, events, MAXEVENTS, <span class="number">5000</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="comment">//校验</span></div><div class="line">            <span class="keyword">if</span> ((events[i].data.fd == efd) &amp;&amp; (events[<span class="number">0</span>].events &amp; EPOLLIN)) &#123;</div><div class="line">                <span class="keyword">eventfd_t</span> r_num;</div><div class="line">                <span class="keyword">ssize_t</span> size = read(efd, &amp;r_num, <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>));</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"parrent read num is %d bytes data from the eventfd, value is %d \n"</span>, size, r_num);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent close eventfd and epfd over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//子进程</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub sleep 3 senconds, and then write\n"</span>);</div><div class="line">        flush(<span class="built_in">cout</span>);</div><div class="line">        <span class="comment">//当前线程睡眠3秒</span></div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="comment">//子进程开始向eventfd设备写入数据</span></div><div class="line">        <span class="keyword">eventfd_t</span> num = <span class="number">18</span>;</div><div class="line">        <span class="keyword">if</span> (write(efd, &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>)) == <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>))<span class="comment">//you can remove this line for learn</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"sub write num %d, over \n"</span>, num);</div><div class="line">        <span class="comment">//关闭子进程eventfd</span></div><div class="line">        close(efd);<span class="comment">//write</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub close write eventfd over \n"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//pid&lt;0, fork error</span></div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error:"</span> &lt;&lt; pid &lt;&lt; <span class="string">", close fds over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://aceld.gitbooks.io/libevent/content/" target="_blank" rel="external">Libevent深入浅出</a><br><br><a href="http://blog.csdn.net/u010657219/article/details/44061629" target="_blank" rel="external">实现机制详解</a><br><br><a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="external">IO多路复用之epoll总结</a><br><br><a href="http://yaocoder.blog.51cto.com/2668309/888374" target="_blank" rel="external">我读过的最好的epoll讲解–转自”知乎“</a><br><br><a href="http://man7.org/linux/man-pages/man2/eventfd.2.html" target="_blank" rel="external">man2:eventfd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;epoll 于Linux 2.5.44引入，旨在替换select和poll系统函数。&lt;/p&gt;
&lt;p&gt;相对于select和poll来说，epoll更加灵活高效:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有监视描述符数量单进程1024限制&lt;/li&gt;
&lt;li&gt;epoll使用一个文件描述符管理
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.molingyu.com/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://www.molingyu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>本博客的建立</title>
    <link href="http://www.molingyu.com/2017/09/17/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>http://www.molingyu.com/2017/09/17/本博客的建立/</id>
    <published>2017-09-16T18:11:22.717Z</published>
    <updated>2017-09-16T18:11:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>白驹过隙，工作已有6个春秋</p><p>回望时，竟然没留下些什么</p><p>或心情、或笔录、或歌词、或曲调、或技术历程</p><p>不免感慨万分</p><p>当我老了，至少在这世间留下些什么文字，孤芳自赏也好</p><h2 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h2><ul><li>从开始学习Java的时候，曾开博客，将java的课本的知识点一一以自己的理解记录下来</li><li>然后自从工作以来，就渐渐不再更新博客，以至于原博客杂草丛生，无人问津，甚至密码都忘记，那会是在csdn，用的邮箱还是yahoo.com.cn，然后就gg了，再也找不回账号了</li><li>现如今，技术成长和技术驱动，俨然已经跟不上脚步，然年近中年，危机四伏</li><li>写博客作为一种重要的学以致用、朝闻夕记的重要手段，不能荒废丢弃</li><li>以前的学习记录，是该定期整理成文，来督促自己去复习管理</li></ul><h2 id="如何写博客"><a href="#如何写博客" class="headerlink" title="如何写博客"></a>如何写博客</h2><p>本博客的博文</p><ul><li>尽自己所能，还原事物本质</li><li>周期性成文，不可懈怠</li><li>前路漫漫，与君共勉</li></ul><h2 id="如何建立站点"><a href="#如何建立站点" class="headerlink" title="如何建立站点"></a>如何建立站点</h2><p>这个部分，网上已经许多文章</p><ul><li><a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/setup.html</a> </li><li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a></li><li><a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="external">https://github.com/limedroid/HexoLearning</a></li></ul><p>我这里主要是提一下npm install遇到的代理问题，很多插件的安装，遇到国墙无法安装，我们需要给npm设置代理才行,<br><a href="https://segmentfault.com/a/1190000002589144" target="_blank" rel="external">参考链接</a>。</p><p>我使用的是Lantern代理，代理的ip和端口，可以从Lanter主页面的Settings的Advance Settins中查看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP(S) proxy : 127.0.0.1:35937</div><div class="line">SOCKS proxy   : 127.0.0.1:38185</div></pre></td></tr></table></figure></p><p>因此，在设置代理的时候，采用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set proxy http://127.0.0.1:35937</div><div class="line">npm config set https-proxy http://127.0.0.1:35937</div></pre></td></tr></table></figure></p><p>后续的插件安装, hexo部署，都能够很顺利的访问</p><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>路漫漫其修远兮，吾将上下而求索 —— 屈原《离骚》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;白驹过隙，工作已有6个春秋&lt;/p&gt;
&lt;p&gt;回望时，竟然没留下些什么&lt;/p&gt;
&lt;p&gt;或心情、或笔录、或歌词、或曲调、或技术历程&lt;/p&gt;
&lt;p&gt;不免感慨万分&lt;/p&gt;
&lt;p&gt;当我老了，至少在这世间留下些什么文字，孤芳自赏也好&lt;/p&gt;
&lt;h2 id=&quot;为什么要写博客&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.molingyu.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.molingyu.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://www.molingyu.com/2017/09/17/ReentrantLock/"/>
    <id>http://www.molingyu.com/2017/09/17/ReentrantLock/</id>
    <published>2017-09-16T18:11:19.429Z</published>
    <updated>2017-09-16T18:11:19.429Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。</p><p>ReentrantLock是Java并发包中互斥锁，它有公平锁和非公平锁两种实现方式，默认构造函数采用非公平锁的方式实现。</p><a id="more"></a><h2 id="lock流程"><a href="#lock流程" class="headerlink" title="lock流程"></a>lock流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认非公平锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据fair来初始化使用哪种锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用FairSync或者NonfairSync的lock方法，默认sync=NonfairSync</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 首先会通过CAS方法，尝试将当前的java.util.concurrent.locks.AbstractQueuedSynchronizer#state中的state字段改成从0改成1</span></div><div class="line"><span class="comment">/*  </span></div><div class="line"><span class="comment">  NonfairSync 继承于 AbstractQueuedSynchronizer， AQS有volatile字段state如下：</span></div><div class="line"><span class="comment">  private volatile int state;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//2. 如果修改成功，则state锁加锁成功，然后将当前线程通过setExclusiveOwnerThread设置为NonfairSync的独占线程</span></div><div class="line"></div><div class="line"><span class="comment">//3. 否则，就像普通线程一样，acquire(1)， 请求加锁</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//aquire(1)方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4. 在tryAcquire(1)中调用nonfairTryAcquire(1)</span></div><div class="line"><span class="comment">//4.1 获取AQS的 state</span></div><div class="line"><span class="comment">//4.1.1 如果c==0,则说明AQS没有加锁，就开始进行CAS操作，成功的化话就setExclusiveOwnerThread，返回true</span></div><div class="line"><span class="comment">//4.1.2 如果c!=0， 则检查当前线程释放为AQS的独占线程，如果是，则int nextc = c + acquires;将state + 1，然后setState(nextc)，并返回true</span></div><div class="line"><span class="comment">//否则返回false</span></div><div class="line"><span class="comment">//PS: 这里的CAS操作，是调用Unsafe类的compareAndSwapInt通过native直接郊游系统操作CPU完成的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5. 如果4的!tryAcquire()成立，即tryAcquire失败，则开始 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span></div><div class="line"><span class="comment">//5.1 首先 addWaiter(Node.EXCLUSIVE)，将当前线程添加到AQS的队列中:</span></div><div class="line"><span class="comment">//(1)首先创建一个为独占模式的Node，</span></div><div class="line"><span class="comment">//(2)再判断一下队列上有没有结点，没有就创建一个空结点头，然后将Node添加到末尾，创建和添加凑采用的是AQS的CAS操作，保证可见性</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2 acquireQueued</span></div><div class="line"><span class="comment">//(1)首先判断node是不是队列第一个，如果是、且尝试获取锁成功，则将node设成head，并把此前的head.next=null，帮助gc回收</span></div><div class="line"><span class="comment">//(2)如果node不是队列第一个，或者获取锁不成功（其他线程还没释放），则进入shouldParkAfterFailedAcquire方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2.1 shouldParkAfterFailedAcquire</span></div><div class="line"><span class="comment">//(1)首次进来，waitStatus肯定为0，那么设置为SIGNAL，并立即返回false。然后返回acquireQueued方法，继续走for循环，再一次尝试获取锁，不成功继续走shouldParkAfterFailedAcquire方法，此时waitStatus=-1，因此这里直接走第一个if，返回true。</span></div><div class="line"><span class="comment">//(2)然后开始走parkAndCheckInterrupt方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * This node has already set status asking a release</span></div><div class="line"><span class="comment">         * to signal it, so it can safely park.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></div><div class="line"><span class="comment">         * indicate retry.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></div><div class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></div><div class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2.2 parkAndCheckInterrupt</span></div><div class="line"><span class="comment">//(1)调用LockSupport的park方法阻塞住了当前的线程</span></div><div class="line"><span class="comment">//(2)至此，使用ReentrantLock让线程1独占锁、线程2进入FIFO队列并阻塞的完整流程已经整理出来了</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    setBlocker(t, blocker);</div><div class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    setBlocker(t, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="unlock流程"><a href="#unlock流程" class="headerlink" title="unlock流程"></a>unlock流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//走AQS（AbstractQueuedSynchronizer）的release流程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//先调用tryRelease尝试释放锁</span></div><div class="line"><span class="comment">//首先，只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的，调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开。</span></div><div class="line"><span class="comment">//当一条线程对同一个ReentrantLock全部解锁之后，AQS的state自然就是0了，AbstractOwnableSynchronizer的exclusiveOwnerThread将被设置为null，这样就表示没有线程占有锁，方法返回true。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div><div class="line"><span class="comment">//代码继续往下走，上面的release方法的第四行，h不为null成立，h的waitStatus为-1，不等于0也成立，所以走第5行的unparkSuccessor方法：</span></div><div class="line"><span class="comment">//s即h的下一个Node，这个Node里面的线程就是线程2，由于这个Node不等于null，所以走21行，线程2被unPark了，得以运行。</span></div><div class="line"><span class="comment">//有一个很重要的问题是：锁被解了怎样保证整个FIFO队列减少一个Node呢？这是一个很巧妙的设计，又回到了AQS的acquireQueued方法了：</span></div><div class="line"><span class="comment">//阻塞完成线程2依然会进行for循环。然后，阻塞完成了，线程2所在的Node的前驱Node是p，线程2尝试tryAcquire，成功，然后线程2就成为了head节点了，把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，h属于栈内存的内容，方法结束被自动回收，这样随着方法的调用完毕，原头Node也没有任何的引用指向它了，这样它就被GC自动回收了。此时，遇到一个return语句，acquireQueued方法结束，后面的Node也是一样的原理。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></div><div class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></div><div class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></div><div class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></div><div class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></div><div class="line"><span class="comment">     * non-cancelled successor.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="公平锁-与-非公平锁"><a href="#公平锁-与-非公平锁" class="headerlink" title="公平锁 与 非公平锁"></a>公平锁 与 非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一上来就进入普通跟拿锁流程：加入队列中，按照lock顺序获得锁。排队，公平</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上来就拿锁，拿不再进入普通拿锁流程，插队，不公平</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/szlbm/p/5505698.html" target="_blank" rel="external">http://www.cnblogs.com/szlbm/p/5505698.html</a></p><p><a href="http://www.cnblogs.com/wanly3643/p/3835839.html" target="_blank" rel="external">http://www.cnblogs.com/wanly3643/p/3835839.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。&lt;/p&gt;
&lt;p&gt;ReentrantLock是Java并发包中互斥锁，它有公平锁和非公平锁两种实现方式，默认构造函数采用非公平锁的方式实现。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://www.molingyu.com/tags/Java/"/>
    
  </entry>
  
</feed>
