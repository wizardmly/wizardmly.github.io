<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子墨不语</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.molingyu.com/"/>
  <updated>2017-09-18T05:51:45.932Z</updated>
  <id>http://www.molingyu.com/</id>
  
  <author>
    <name>子墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个epoll实例</title>
    <link href="http://www.molingyu.com/2017/09/18/%E4%B8%80%E4%B8%AAepoll%E5%AE%9E%E4%BE%8B/"/>
    <id>http://www.molingyu.com/2017/09/18/一个epoll实例/</id>
    <published>2017-09-18T05:51:45.932Z</published>
    <updated>2017-09-18T05:51:45.932Z</updated>
    
    <content type="html"><![CDATA[<p>epoll 于Linux 2.5.44引入，旨在替换select和poll系统函数。</p><p>相对于select和poll来说，epoll更加灵活高效:</p><ul><li>没有监视描述符数量单进程1024限制</li><li>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</li></ul><h2 id="epoll在Android中的应用"><a href="#epoll在Android中的应用" class="headerlink" title="epoll在Android中的应用"></a>epoll在Android中的应用</h2><p>epoll机制在Android系统中扮演着一个很重要的角色，</p><ol><li>在MessageQueue的队列中，当队列为空时需要阻塞Looper线程，队列非空时候需要唤醒线程，使用到了epoll + eventfd(比pipe更高效的事件驱动，在<a href="https://cloud.seu.edu.cn/gitlab/frederickjoe/android-aosp-sdcard/commit/8892ce6383c7aa3e18107b94889882a0374de69f" target="_blank" rel="external">6.0引入</a>)机制，高效的管理着消息队列</li><li>java NIO中 Selector采用了epoll机制实现SocketChannel管道事件轮询</li></ol><h2 id="实例代码（采用epoll-pipe实现）"><a href="#实例代码（采用epoll-pipe实现）" class="headerlink" title="实例代码（采用epoll + pipe实现）"></a>实例代码（采用epoll + pipe实现）</h2><p>本例我们采用 epoll + pipe的机制，简单的模拟一个通信唤醒的场景来理解epoll通信，更深入的理解，可以阅读libevent源码</p><ol><li>创建管道</li><li>创建epll事件：并设置关注的事件类型</li><li>创建epoll</li><li>往epoll注册事件</li><li>fork一个子进程，sleep(3)秒后，往管道写入数据</li><li>父进程挂起，监听事件源(管道读取端fd)事件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//最大事件数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXEVENTS = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 1. 创建管道，并将管道两端的fd存放在数组pipe_fd中</span></div><div class="line"><span class="comment">     * pipe_fd[0] ： 管道输出端，可读取fd</span></div><div class="line"><span class="comment">     * pipe_fd[1] ： 管道输入端，可写入fd</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">if</span> ((ret = pipe(pipe_fd)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"create pipe fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 2. 创建epoll关注事件源的事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></div><div class="line">    <span class="comment">//设置监听事件源</span></div><div class="line">    ev.data.fd = pipe_fd[<span class="number">0</span>];</div><div class="line">    <span class="comment">//设置监听什么事件：EPOLLIN, 事件源可读事件， EPOLLET 边缘触发模式(Edge Triggered)</span></div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 3. 创建epoll对象，返回epoll对象的fd地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(MAXEVENTS);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 4. 往epoll对象中 添加/修改/删除 一个事件(事件源fd, 事件类型&amp;ev)</span></div><div class="line"><span class="comment">     * EPOLL_CTL_ADD：注册新的fd到epfd中；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_DEL：从epfd中删除一个fd；</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev);</div><div class="line">    <span class="comment">//校验</span></div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_ctl fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fork一个进程，来读取epoll事件</span></div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></div><div class="line">        <span class="comment">//监听事件数组</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 6. 使用epoll，开始监听事件，并将事件放置到数组events中</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * epoll_wait会阻塞当前线程，当监听的事件发生的时候，会唤醒该线程</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">int</span> count = epoll_wait(epfd, events, MAXEVENTS, <span class="number">5000</span>);</div><div class="line">        <span class="keyword">char</span> r_buf[<span class="number">100</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="comment">//校验</span></div><div class="line">            <span class="keyword">if</span> ((events[i].data.fd == pipe_fd[<span class="number">0</span>]) &amp;&amp; (events[<span class="number">0</span>].events &amp; EPOLLIN)) &#123;</div><div class="line">                <span class="keyword">int</span> r_num = read(pipe_fd[<span class="number">0</span>], r_buf, <span class="number">100</span>);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"parrent read num is %d bytes data from the pipe, value is %d \n"</span>, r_num, atoi(r_buf));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent close read fd[0], wirte fd[1] and epfd over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//子进程</span></div><div class="line">        <span class="comment">//子进程不进行读取操作，关闭读取fd</span></div><div class="line">        close(pipe_fd[<span class="number">0</span>]);<span class="comment">//read</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sub does't read, so close read fd[0], over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">        <span class="comment">//当前线程睡眠3秒</span></div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 5. 子进程开始向管道写入数据，触发EPOLLIN事件</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">char</span> w_buf[<span class="number">100</span>];</div><div class="line">        <span class="built_in">strcpy</span>(w_buf, <span class="string">"1234"</span>);</div><div class="line">        <span class="keyword">if</span> (write(pipe_fd[<span class="number">1</span>], w_buf, <span class="number">5</span>) != <span class="number">-1</span>)<span class="comment">//you can remove this line for learn</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"sub write write num 1234, over \n"</span>);</div><div class="line">        <span class="comment">//关闭写入端管道fd</span></div><div class="line">        close(pipe_fd[<span class="number">1</span>]);<span class="comment">//write</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub close write fd[1] over \n"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//pid&lt;0, fork error</span></div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error:"</span> &lt;&lt; pid &lt;&lt; <span class="string">", close fds over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="改用epoll-eventfd来实现"><a href="#改用epoll-eventfd来实现" class="headerlink" title="改用epoll + eventfd来实现"></a>改用epoll + eventfd来实现</h2><p>eventfd在2.6.22引入，是比pipe更高效的线程间事件通知机制，它的缓冲区只有8个字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Created by milo on 17-9-18.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXEVENTS = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * eventfd (unsigned int __count, int __flags)</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * man: http://man7.org/linux/man-pages/man2/eventfd.2.html</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * initval: eventfd设备初始值</span></div><div class="line"><span class="comment">     * flags: 在2.6.26之前的版本，必须设置为0，之后的版本有以下值：</span></div><div class="line"><span class="comment">     *     EFD_SEMAPHORE</span></div><div class="line"><span class="comment">     *     EFD_CLOEXEC</span></div><div class="line"><span class="comment">     *     EFD_NONBLOCK</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 1. 创建epoll关注事件源的事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></div><div class="line">    <span class="comment">//设置监听事件源</span></div><div class="line">    ev.data.fd = efd;</div><div class="line">    <span class="comment">//设置监听什么事件：EPOLLIN, 事件源可读事件， EPOLLET 边缘触发模式(Edge Triggered)</span></div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 2. 创建epoll对象，返回epoll对象的fd地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(MAXEVENTS);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 3. 往epoll对象中 添加/修改/删除 一个事件(事件源fd, 事件类型&amp;ev)</span></div><div class="line"><span class="comment">     * EPOLL_CTL_ADD：注册新的fd到epfd中；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_DEL：从epfd中删除一个fd；</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, efd, &amp;ev);</div><div class="line">    <span class="comment">//校验</span></div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_ctl fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fork一个进程，来读取epoll事件</span></div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></div><div class="line">        <span class="comment">//监听事件数组</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 4. 使用epoll，开始监听事件源，并将事件放置到数组events中</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * epoll_wait会阻塞当前线程，当监听的事件发生的时候，会唤醒该线程</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">int</span> count = epoll_wait(epfd, events, MAXEVENTS, <span class="number">5000</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="comment">//校验</span></div><div class="line">            <span class="keyword">if</span> ((events[i].data.fd == efd) &amp;&amp; (events[<span class="number">0</span>].events &amp; EPOLLIN)) &#123;</div><div class="line">                <span class="keyword">eventfd_t</span> r_num;</div><div class="line">                <span class="keyword">ssize_t</span> size = read(efd, &amp;r_num, <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>));</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"parrent read num is %d bytes data from the eventfd, value is %d \n"</span>, size, r_num);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent close eventfd and epfd over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//子进程</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub sleep 3 senconds, and then write\n"</span>);</div><div class="line">        flush(<span class="built_in">cout</span>);</div><div class="line">        <span class="comment">//当前线程睡眠3秒</span></div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="comment">//子进程开始向eventfd设备写入数据</span></div><div class="line">        <span class="keyword">eventfd_t</span> num = <span class="number">18</span>;</div><div class="line">        <span class="keyword">if</span> (write(efd, &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>)) == <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>))<span class="comment">//you can remove this line for learn</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"sub write num %d, over \n"</span>, num);</div><div class="line">        <span class="comment">//关闭子进程eventfd</span></div><div class="line">        close(efd);<span class="comment">//write</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub close write eventfd over \n"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//pid&lt;0, fork error</span></div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error:"</span> &lt;&lt; pid &lt;&lt; <span class="string">", close fds over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://aceld.gitbooks.io/libevent/content/" target="_blank" rel="external">Libevent深入浅出</a><br><br><a href="http://blog.csdn.net/u010657219/article/details/44061629" target="_blank" rel="external">实现机制详解</a><br><br><a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="external">IO多路复用之epoll总结</a><br><br><a href="http://yaocoder.blog.51cto.com/2668309/888374" target="_blank" rel="external">我读过的最好的epoll讲解–转自”知乎“</a><br><br><a href="http://man7.org/linux/man-pages/man2/eventfd.2.html" target="_blank" rel="external">man2:eventfd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;epoll 于Linux 2.5.44引入，旨在替换select和poll系统函数。&lt;/p&gt;
&lt;p&gt;相对于select和poll来说，epoll更加灵活高效:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有监视描述符数量单进程1024限制&lt;/li&gt;
&lt;li&gt;epoll使用一个文件描述符管理
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.molingyu.com/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://www.molingyu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>本博客的建立</title>
    <link href="http://www.molingyu.com/2017/09/17/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>http://www.molingyu.com/2017/09/17/本博客的建立/</id>
    <published>2017-09-16T18:11:22.717Z</published>
    <updated>2017-09-16T18:11:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>白驹过隙，工作已有6个春秋</p><p>回望时，竟然没留下些什么</p><p>或心情、或笔录、或歌词、或曲调、或技术历程</p><p>不免感慨万分</p><p>当我老了，至少在这世间留下些什么文字，孤芳自赏也好</p><h2 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h2><ul><li>从开始学习Java的时候，曾开博客，将java的课本的知识点一一以自己的理解记录下来</li><li>然后自从工作以来，就渐渐不再更新博客，以至于原博客杂草丛生，无人问津，甚至密码都忘记，那会是在csdn，用的邮箱还是yahoo.com.cn，然后就gg了，再也找不回账号了</li><li>现如今，技术成长和技术驱动，俨然已经跟不上脚步，然年近中年，危机四伏</li><li>写博客作为一种重要的学以致用、朝闻夕记的重要手段，不能荒废丢弃</li><li>以前的学习记录，是该定期整理成文，来督促自己去复习管理</li></ul><h2 id="如何写博客"><a href="#如何写博客" class="headerlink" title="如何写博客"></a>如何写博客</h2><p>本博客的博文</p><ul><li>尽自己所能，还原事物本质</li><li>周期性成文，不可懈怠</li><li>前路漫漫，与君共勉</li></ul><h2 id="如何建立站点"><a href="#如何建立站点" class="headerlink" title="如何建立站点"></a>如何建立站点</h2><p>这个部分，网上已经许多文章</p><ul><li><a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/setup.html</a> </li><li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a></li><li><a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="external">https://github.com/limedroid/HexoLearning</a></li></ul><p>我这里主要是提一下npm install遇到的代理问题，很多插件的安装，遇到国墙无法安装，我们需要给npm设置代理才行,<br><a href="https://segmentfault.com/a/1190000002589144" target="_blank" rel="external">参考链接</a>。</p><p>我使用的是Lantern代理，代理的ip和端口，可以从Lanter主页面的Settings的Advance Settins中查看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP(S) proxy : 127.0.0.1:35937</div><div class="line">SOCKS proxy   : 127.0.0.1:38185</div></pre></td></tr></table></figure></p><p>因此，在设置代理的时候，采用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set proxy http://127.0.0.1:35937</div><div class="line">npm config set https-proxy http://127.0.0.1:35937</div></pre></td></tr></table></figure></p><p>后续的插件安装, hexo部署，都能够很顺利的访问</p><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>路漫漫其修远兮，吾将上下而求索 —— 屈原《离骚》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;白驹过隙，工作已有6个春秋&lt;/p&gt;
&lt;p&gt;回望时，竟然没留下些什么&lt;/p&gt;
&lt;p&gt;或心情、或笔录、或歌词、或曲调、或技术历程&lt;/p&gt;
&lt;p&gt;不免感慨万分&lt;/p&gt;
&lt;p&gt;当我老了，至少在这世间留下些什么文字，孤芳自赏也好&lt;/p&gt;
&lt;h2 id=&quot;为什么要写博客&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.molingyu.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.molingyu.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://www.molingyu.com/2017/09/17/ReentrantLock/"/>
    <id>http://www.molingyu.com/2017/09/17/ReentrantLock/</id>
    <published>2017-09-16T18:11:19.429Z</published>
    <updated>2017-09-16T18:11:19.429Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。</p><p>ReentrantLock是Java并发包中互斥锁，它有公平锁和非公平锁两种实现方式，默认构造函数采用非公平锁的方式实现。</p><a id="more"></a><h2 id="lock流程"><a href="#lock流程" class="headerlink" title="lock流程"></a>lock流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认非公平锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据fair来初始化使用哪种锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用FairSync或者NonfairSync的lock方法，默认sync=NonfairSync</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 首先会通过CAS方法，尝试将当前的java.util.concurrent.locks.AbstractQueuedSynchronizer#state中的state字段改成从0改成1</span></div><div class="line"><span class="comment">/*  </span></div><div class="line"><span class="comment">  NonfairSync 继承于 AbstractQueuedSynchronizer， AQS有volatile字段state如下：</span></div><div class="line"><span class="comment">  private volatile int state;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//2. 如果修改成功，则state锁加锁成功，然后将当前线程通过setExclusiveOwnerThread设置为NonfairSync的独占线程</span></div><div class="line"></div><div class="line"><span class="comment">//3. 否则，就像普通线程一样，acquire(1)， 请求加锁</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//aquire(1)方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4. 在tryAcquire(1)中调用nonfairTryAcquire(1)</span></div><div class="line"><span class="comment">//4.1 获取AQS的 state</span></div><div class="line"><span class="comment">//4.1.1 如果c==0,则说明AQS没有加锁，就开始进行CAS操作，成功的化话就setExclusiveOwnerThread，返回true</span></div><div class="line"><span class="comment">//4.1.2 如果c!=0， 则检查当前线程释放为AQS的独占线程，如果是，则int nextc = c + acquires;将state + 1，然后setState(nextc)，并返回true</span></div><div class="line"><span class="comment">//否则返回false</span></div><div class="line"><span class="comment">//PS: 这里的CAS操作，是调用Unsafe类的compareAndSwapInt通过native直接郊游系统操作CPU完成的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5. 如果4的!tryAcquire()成立，即tryAcquire失败，则开始 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span></div><div class="line"><span class="comment">//5.1 首先 addWaiter(Node.EXCLUSIVE)，将当前线程添加到AQS的队列中:</span></div><div class="line"><span class="comment">//(1)首先创建一个为独占模式的Node，</span></div><div class="line"><span class="comment">//(2)再判断一下队列上有没有结点，没有就创建一个空结点头，然后将Node添加到末尾，创建和添加凑采用的是AQS的CAS操作，保证可见性</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2 acquireQueued</span></div><div class="line"><span class="comment">//(1)首先判断node是不是队列第一个，如果是、且尝试获取锁成功，则将node设成head，并把此前的head.next=null，帮助gc回收</span></div><div class="line"><span class="comment">//(2)如果node不是队列第一个，或者获取锁不成功（其他线程还没释放），则进入shouldParkAfterFailedAcquire方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2.1 shouldParkAfterFailedAcquire</span></div><div class="line"><span class="comment">//(1)首次进来，waitStatus肯定为0，那么设置为SIGNAL，并立即返回false。然后返回acquireQueued方法，继续走for循环，再一次尝试获取锁，不成功继续走shouldParkAfterFailedAcquire方法，此时waitStatus=-1，因此这里直接走第一个if，返回true。</span></div><div class="line"><span class="comment">//(2)然后开始走parkAndCheckInterrupt方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * This node has already set status asking a release</span></div><div class="line"><span class="comment">         * to signal it, so it can safely park.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></div><div class="line"><span class="comment">         * indicate retry.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></div><div class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></div><div class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2.2 parkAndCheckInterrupt</span></div><div class="line"><span class="comment">//(1)调用LockSupport的park方法阻塞住了当前的线程</span></div><div class="line"><span class="comment">//(2)至此，使用ReentrantLock让线程1独占锁、线程2进入FIFO队列并阻塞的完整流程已经整理出来了</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    setBlocker(t, blocker);</div><div class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    setBlocker(t, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="unlock流程"><a href="#unlock流程" class="headerlink" title="unlock流程"></a>unlock流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//走AQS（AbstractQueuedSynchronizer）的release流程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//先调用tryRelease尝试释放锁</span></div><div class="line"><span class="comment">//首先，只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的，调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开。</span></div><div class="line"><span class="comment">//当一条线程对同一个ReentrantLock全部解锁之后，AQS的state自然就是0了，AbstractOwnableSynchronizer的exclusiveOwnerThread将被设置为null，这样就表示没有线程占有锁，方法返回true。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div><div class="line"><span class="comment">//代码继续往下走，上面的release方法的第四行，h不为null成立，h的waitStatus为-1，不等于0也成立，所以走第5行的unparkSuccessor方法：</span></div><div class="line"><span class="comment">//s即h的下一个Node，这个Node里面的线程就是线程2，由于这个Node不等于null，所以走21行，线程2被unPark了，得以运行。</span></div><div class="line"><span class="comment">//有一个很重要的问题是：锁被解了怎样保证整个FIFO队列减少一个Node呢？这是一个很巧妙的设计，又回到了AQS的acquireQueued方法了：</span></div><div class="line"><span class="comment">//阻塞完成线程2依然会进行for循环。然后，阻塞完成了，线程2所在的Node的前驱Node是p，线程2尝试tryAcquire，成功，然后线程2就成为了head节点了，把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，h属于栈内存的内容，方法结束被自动回收，这样随着方法的调用完毕，原头Node也没有任何的引用指向它了，这样它就被GC自动回收了。此时，遇到一个return语句，acquireQueued方法结束，后面的Node也是一样的原理。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></div><div class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></div><div class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></div><div class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></div><div class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></div><div class="line"><span class="comment">     * non-cancelled successor.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="公平锁-与-非公平锁"><a href="#公平锁-与-非公平锁" class="headerlink" title="公平锁 与 非公平锁"></a>公平锁 与 非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一上来就进入普通跟拿锁流程：加入队列中，按照lock顺序获得锁。排队，公平</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上来就拿锁，拿不再进入普通拿锁流程，插队，不公平</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/szlbm/p/5505698.html" target="_blank" rel="external">http://www.cnblogs.com/szlbm/p/5505698.html</a></p><p><a href="http://www.cnblogs.com/wanly3643/p/3835839.html" target="_blank" rel="external">http://www.cnblogs.com/wanly3643/p/3835839.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。&lt;/p&gt;
&lt;p&gt;ReentrantLock是Java并发包中互斥锁，它有公平锁和非公平锁两种实现方式，默认构造函数采用非公平锁的方式实现。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://www.molingyu.com/tags/Java/"/>
    
  </entry>
  
</feed>
