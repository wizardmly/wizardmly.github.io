<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子墨不语</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.molingyu.com/"/>
  <updated>2017-09-26T20:17:43.851Z</updated>
  <id>http://www.molingyu.com/</id>
  
  <author>
    <name>子墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android启动源码阅读(二)zygote进程的启动</title>
    <link href="http://www.molingyu.com/2017/09/27/Android%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%BA%8C)zygote%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
    <id>http://www.molingyu.com/2017/09/27/Android启动源码阅读(二)zygote进程的启动/</id>
    <published>2017-09-26T20:17:43.851Z</published>
    <updated>2017-09-26T20:17:43.851Z</updated>
    
    <content type="html"><![CDATA[<p>从上一篇<a href="http://molingyu.com/2017/09/26/Android%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)init%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8/" target="_blank" rel="external">init的启动</a>可以看到，zygote由init进程解析init.zygoteXXX.rc文件，然后fork进程，并为zygote进程创建了/dev/socket/zygote的socket接口，然后创建zygote进程，执行/system/bin/app_process，传入参数：-Xzygote /system/bin –zygote –start-system-server</p><p>本文，我们看下app_process干了些什么事情</p><p>仍然是AndroidStudio查找源码的流程：</p><ol><li>Ctrl + Shift + F 全局查找字符串 <em>:= app_process</em></li><li>找到Android.mk文件：frameworks/base/cmds/app_process/Android.mk</li><li>对应的LOCAL_SRC_FILES:= \app_main.cpp，因此app_process的源码位于frameworks/base/cmds/app_process/app_main.cpp中</li></ol><h1 id="开始阅读-app-main-cpp-gt-main-方法"><a href="#开始阅读-app-main-cpp-gt-main-方法" class="headerlink" title="开始阅读:app_main.cpp -&gt; main()方法"></a>开始阅读:app_main.cpp -&gt; main()方法</h1><p>记住，在init在执行的时候，入参是:-Xzygote /system/bin –zygote –start-system-server，解析得到的args = {“-Xzygote” “/system/bin”，”-zygote“， ”-start-system-server“}，携带这些参数，我们来看下main方法的执行情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用argv[0]参数进行</span></div><div class="line">AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</div><div class="line"><span class="comment">// Process command line arguments</span></div><div class="line"><span class="comment">// ignore argv[0], 忽略argv[0]参数</span></div><div class="line"><span class="comment">//argc-1 = 3</span></div><div class="line">argc--;</div><div class="line"><span class="comment">//argv++，即数组头指针后移一个位置</span></div><div class="line">argv++;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</div><div class="line">    <span class="comment">//如果参数不是以'-'开头，直接跳出循环</span></div><div class="line">    <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果参数第二个字符为'-'并且第三个字符为截止字符，则忽略，并跳出循环</span></div><div class="line">    <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</div><div class="line">        ++i; <span class="comment">// Skip --.</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//为runtime添加参数</span></div><div class="line">    runtime.addOption(strdup(argv[i]));</div><div class="line">&#125;</div><div class="line"><span class="comment">//因此，因为此前的argv++，故而argv[0]="/syste/bin"，故而跳出上述循环，此时i = 0</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">//++i，跳过了第一个参数/system/bin，即跳过父目录参数</span></div><div class="line">++i;  <span class="comment">// Skip unused "parent dir" argument.</span></div><div class="line"><span class="comment">//继续执行</span></div><div class="line"><span class="keyword">while</span> (i &lt; argc) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</div><div class="line">    <span class="comment">//i = 1, argv[1] = "--zygote"， 然后i++</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</div><div class="line">        zygote = <span class="literal">true</span>;</div><div class="line">        niceName = ZYGOTE_NICE_NAME;</div><div class="line">    <span class="comment">//i = 1, argv[2] = "-start-system-server"， 然后i++=3 = argc，跳出循环</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</div><div class="line">        startSystemServer = <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</div><div class="line">        application = <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</div><div class="line">        niceName.setTo(arg + <span class="number">12</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</div><div class="line">        className.setTo(arg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        --i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//因此上述while做了几个事情：</span></div><div class="line"><span class="comment">//1. zygote = true;</span></div><div class="line"><span class="comment">//2. niceName = ZYGOTE_NICE_NAME; // zygote或者zygote64</span></div><div class="line"><span class="comment">//3. startSystemServer = true;</span></div><div class="line"></div><div class="line"><span class="comment">//下面代码的注释已经比较清除了，args是runtime.start(）要传入的参数之一</span></div><div class="line">Vector&lt;String8&gt; args;</div><div class="line"><span class="keyword">if</span> (!className.isEmpty()) &#123;</div><div class="line">    <span class="comment">// We're not in zygote mode, the only argument we need to pass</span></div><div class="line">    <span class="comment">// to RuntimeInit is the application argument.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></div><div class="line">    <span class="comment">// copies of them before we overwrite them with the process name.</span></div><div class="line">    args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</div><div class="line">    runtime.setClassNameAndArgs(className, argc - i, argv + i);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// We're in zygote mode.</span></div><div class="line">    maybeCreateDalvikCache();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</div><div class="line">        args.add(String8(<span class="string">"start-system-server"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> prop[PROP_VALUE_MAX];</div><div class="line">    <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</div><div class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</div><div class="line">            ABI_LIST_PROPERTY);</div><div class="line">        <span class="keyword">return</span> <span class="number">11</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</div><div class="line">    abiFlag.append(prop);</div><div class="line">    args.add(abiFlag);</div><div class="line"></div><div class="line">    <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></div><div class="line">    <span class="comment">// main() method.</span></div><div class="line">    <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</div><div class="line">        args.add(String8(argv[i]));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置进程名称</span></div><div class="line"><span class="keyword">if</span> (!niceName.isEmpty()) &#123;</div><div class="line">    runtime.setArgv0(niceName.<span class="built_in">string</span>());</div><div class="line">    set_process_name(niceName.<span class="built_in">string</span>());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (zygote) &#123;</div><div class="line">    <span class="comment">//进入AppRuntime.start方法</span></div><div class="line">    runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</div><div class="line">    runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</div><div class="line">    app_usage();</div><div class="line">    LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="AppRuntime-gt-start-方法"><a href="#AppRuntime-gt-start-方法" class="headerlink" title="AppRuntime-&gt;start()方法"></a>AppRuntime-&gt;start()方法</h1><p>AppRuntime的定义在app_main.cpp中，继承于AndroidRuntime类，类文件位于frameworks/base/core/jni/AndroidRuntime.cpp，头文件位于frameworks/base/include/android_runtime/AndroidRuntime.h</p><p>而AppRuntime主要重写了几个方法：</p><ul><li>onVmCreated</li><li>onStarted</li><li>onZygoteInit</li><li>onExit</li><li>并定义了方法setClassNameAndArgs</li><li>新增了几个成员：String8 mClassName, Vector<string8> mArgs, jclass mClass;</string8></li></ul><p>start方法位于AndroidRuntime中定义，我们来看看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</div><div class="line">&#123;</div><div class="line">  <span class="comment">//startSystemServer = "start-system-server"</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">//将rootDir设置为"/system"</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//1. 启动虚拟机</span></div><div class="line">  <span class="comment">/* start the virtual machine */</span></div><div class="line">  JniInvocation jni_invocation;</div><div class="line">  jni_invocation.Init(<span class="literal">NULL</span>);</div><div class="line">  JNIEnv* env;  <span class="comment">//虚拟机环境指针</span></div><div class="line">  <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  onVmCreated(env);</div><div class="line">  </div><div class="line">  <span class="comment">//注册jni函数</span></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Register android functions.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</div><div class="line">      ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * We want to call main() with a String array with arguments in it.</span></div><div class="line"><span class="comment">   * At present we have two arguments, the class name and an option string.</span></div><div class="line"><span class="comment">   * Create an array to hold them.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  jclass stringClass;</div><div class="line">  jobjectArray strArray;</div><div class="line">  jstring classNameStr;</div><div class="line"></div><div class="line">  stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</div><div class="line">  assert(stringClass != <span class="literal">NULL</span>);</div><div class="line">  strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</div><div class="line">  assert(strArray != <span class="literal">NULL</span>);</div><div class="line">  classNameStr = env-&gt;NewStringUTF(className);</div><div class="line">  assert(classNameStr != <span class="literal">NULL</span>);</div><div class="line">  env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</div><div class="line">      jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</div><div class="line">      assert(optionsStr != <span class="literal">NULL</span>);</div><div class="line">      env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Start VM.</span></div><div class="line"><span class="comment">   * 注意以下两点</span></div><div class="line"><span class="comment">   * 1. This thread becomes the main thread of the VM, </span></div><div class="line"><span class="comment">   * 2. and will not return until the VM exits.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</div><div class="line">  <span class="comment">//找到class字节码实例：com.android.internal.os.ZygoteInit.class</span></div><div class="line">  jclass startClass = env-&gt;FindClass(slashClassName);</div><div class="line">  <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</div><div class="line">      ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</div><div class="line">      <span class="comment">/* keep going */</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//找到main函数</span></div><div class="line">      jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>, <span class="string">"([Ljava/lang/String;)V"</span>);</div><div class="line">      <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</div><div class="line">          ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</div><div class="line">          <span class="comment">/* keep going */</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//调用main函数，进入ZygoteInit.main()中，直到main函数退出（此时虚拟机也会退出）</span></div><div class="line">          env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">          <span class="comment">//未正常退出</span></div><div class="line">          <span class="keyword">if</span> (env-&gt;ExceptionCheck())</div><div class="line">              threadExitUncaughtException(env);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">free</span>(slashClassName);</div><div class="line">  <span class="comment">//虚拟机退出</span></div><div class="line">  ALOGD(<span class="string">"Shutting down VM\n"</span>);</div><div class="line">  <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</div><div class="line">      ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</div><div class="line">  <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</div><div class="line">      ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中：</p><ul><li>startVm(): 一系列的虚拟机环境参数配置，最终调用JNI_CreateJavaVM初始化虚拟机，如果方法调用成功，则虚拟机准备完毕，这部分是dalvikVm的知识，以后再研究</li><li>startReg(): 主要通过register_jni_procs来注册jni函数，如register_com_android_internal_os_RuntimeInit、register_android_opengl<em>jni</em>…等等jni library</li></ul><h1 id="启动虚拟机之后，进入Java世界-ZygoteInit-main"><a href="#启动虚拟机之后，进入Java世界-ZygoteInit-main" class="headerlink" title="启动虚拟机之后，进入Java世界: ZygoteInit.main()"></a>启动虚拟机之后，进入Java世界: ZygoteInit.main()</h1><p>还是来看代码, </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</div><div class="line">  <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></div><div class="line">  <span class="comment">// an error.</span></div><div class="line">  ZygoteHooks.startZygoteNoThreadCreation();</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//调试相关</span></div><div class="line">      Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="string">"ZygoteInit"</span>);</div><div class="line">      /开启ddms</div><div class="line">      RuntimeInit.enableDdms();</div><div class="line">      <span class="comment">// Start profiling the zygote initialization.</span></div><div class="line">      SamplingProfilerIntegration.start();</div><div class="line">      </div><div class="line">      </div><div class="line">      boolean startSystemServer = <span class="literal">false</span>;</div><div class="line">      String socketName = <span class="string">"zygote"</span>;</div><div class="line">      String abiList = null;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</div><div class="line">          <span class="comment">//是否需要启动systemserver: zygote进程启动时候，true</span></div><div class="line">          <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</div><div class="line">              startSystemServer = <span class="literal">true</span>;</div><div class="line">          <span class="comment">//是否包含abilist，zygote进程，true</span></div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class="line">              abiList = argv[i].substring(ABI_LIST_ARG.length());</div><div class="line">          <span class="comment">//是否包含socketname，zygote进程，true</span></div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class="line">              socketName = argv[i].substring(SOCKET_NAME_ARG.length());</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (abiList == null) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No ABI list supplied."</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//注册zygote的socket服务端接口</span></div><div class="line">      registerZygoteSocket(socketName);</div><div class="line">      Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="string">"ZygotePreload"</span>);</div><div class="line">      EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</div><div class="line">          SystemClock.uptimeMillis());</div><div class="line">      <span class="comment">//预加载：类、资源、opengl已经共享库等等，这样在fork一个新的进程的时，就不再需要重新加载这些资源</span></div><div class="line">      <span class="comment">//而由于linux的fork机制，这些预加载的资源，除非有修改需求，否则都共享父进程的同一个资源</span></div><div class="line">      preload();</div><div class="line">      EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</div><div class="line">          SystemClock.uptimeMillis());</div><div class="line">      Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class="line"></div><div class="line">      <span class="comment">// Finish profiling the zygote initialization.</span></div><div class="line">      SamplingProfilerIntegration.writeZygoteSnapshot();</div><div class="line"></div><div class="line">      <span class="comment">// Do an initial gc to clean up after startup</span></div><div class="line">      Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="string">"PostZygoteInitGC"</span>);</div><div class="line">      <span class="comment">//进行依次gc回收</span></div><div class="line">      gcAndFinalize();</div><div class="line">      Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class="line"></div><div class="line">      Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class="line"></div><div class="line">      <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags from</span></div><div class="line">      <span class="comment">// Zygote.</span></div><div class="line">      Trace.setTracingEnabled(<span class="literal">false</span>);</div><div class="line"></div><div class="line">      <span class="comment">// Zygote process unmounts root storage spaces.</span></div><div class="line">      Zygote.nativeUnmountStorageOnInit();</div><div class="line"></div><div class="line">      ZygoteHooks.stopZygoteNoThreadCreation();</div><div class="line">      </div><div class="line">      <span class="comment">//启动SystemServer进程</span></div><div class="line">      <span class="keyword">if</span> (startSystemServer) &#123;</div><div class="line">          startSystemServer(abiList, socketName);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</div><div class="line">      <span class="comment">//进入select loop循环</span></div><div class="line">      runSelectLoop(abiList);</div><div class="line">      <span class="comment">//关闭服务端server socket</span></div><div class="line">      closeServerSocket();</div><div class="line">  &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</div><div class="line">      <span class="comment">//caller.run()</span></div><div class="line">      caller.run();</div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">      Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</div><div class="line">      closeServerSocket();</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>小结，ZygoteInit.main()主要做了几件事情：</p><ol><li>registerZygoteSocket，注册zygote的socket服务，等待其他client的请求</li><li>startSystemServer开启systemserver进程，这是java世界的基石：包含了众多的服务，如AMS, WMS，IMS等等</li><li>调用runSelectLoop，进入无限循环，等待client请求，来创建进程，每创建一个进程，在子进程中都会抛出异常MethodAndArgsCaller，从而子进程中的代码会运行到caller.run()方法中去</li></ol><h2 id="1-registerZygoteSocket"><a href="#1-registerZygoteSocket" class="headerlink" title="1. registerZygoteSocket()"></a>1. registerZygoteSocket()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//入参是"zygote"</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">(String socketName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sServerSocket == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> fileDesc;</div><div class="line">        <span class="comment">//由于zygote进程创建的时候，会创建名为zygote的socket节点的fd，并将节点设置到环境变量ANDROID_SOCKET_zygote中去</span></div><div class="line">        <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String env = System.getenv(fullSocketName);</div><div class="line">            fileDesc = Integer.parseInt(env);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(fullSocketName + <span class="string">" unset or invalid"</span>, ex);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">            fd.setInt$(fileDesc);</div><div class="line">            <span class="comment">//创建socket的server端</span></div><div class="line">            sServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Error binding to local socket '"</span> + fileDesc + <span class="string">"'"</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-startSystemServer"><a href="#2-startSystemServer" class="headerlink" title="2. startSystemServer()"></a>2. startSystemServer()</h2><p>另外开一篇文章来写吧，这里我们记住，system_server进程，由zygote进程fork出来，然后在创建的虚拟机中执行SystemServer.main()方法</p><h2 id="3-runSelectLoop"><a href="#3-runSelectLoop" class="headerlink" title="3. runSelectLoop()"></a>3. runSelectLoop()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</div><div class="line">    <span class="comment">//fds和peers一一对应</span></div><div class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</div><div class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">//服务端的fd对应着null值</span></div><div class="line">    fds.add(sServerSocket.getFileDescriptor());</div><div class="line">    peers.add(<span class="keyword">null</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//进入无限循环， 采用 多路复用机制 + socket配合 进行阻塞等待client的请求</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">//监听所有的fd的POLLIN请求，即监听socket可读事件</span></div><div class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</div><div class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</div><div class="line">            <span class="comment">////pollFds[0]即为fds[0]，也就是sServerSocket.fd</span></div><div class="line">            <span class="comment">//1. 一开始，zygote刚启动的时候，这个fds只有sServerSocket.fd一个元素</span></div><div class="line">            <span class="comment">//2. 当有新的client连接sServerSocket时候，就会触发sServerSocket.fd的POLLIN事件</span></div><div class="line">            <span class="comment">//3. 从而导致后面for循环中，i==0成立，然后往peers中新加一个peers，以及往fds列表中添加客户端的fd</span></div><div class="line">            pollFds[i].fd = fds.get(i);</div><div class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//开始poll系统调用，监听多个文件的POLLIN事件，阻塞。 当有事件来临时，继续往下执行</span></div><div class="line">            Os.poll(pollFds, -<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遍历所有监控的fd，如果不存在POLLIN事件，则continue跳过该fd，否则执行后面的操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//i=0，说明是zygote进程的server端的socket，因此调用socket.accept，获取与客户端的链接，从而拿到fd</span></div><div class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class="line">                peers.add(newPeer);</div><div class="line">                <span class="comment">//添加到fds列表</span></div><div class="line">                fds.add(newPeer.getFileDesciptor());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//处理客户端链接</span></div><div class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</div><div class="line">                <span class="comment">//处理完毕，将fd和peers删除</span></div><div class="line">                <span class="keyword">if</span> (done) &#123;</div><div class="line">                    peers.remove(i);</div><div class="line">                    fds.remove(i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>开启sServerSocket，等待客户端请求</li><li>客户端请求来临，调用ZygoteConnection.runOnce()处理请求</li></ol><h3 id="3-1-调用ZygoteConnection-runOnce-处理请求"><a href="#3-1-调用ZygoteConnection-runOnce-处理请求" class="headerlink" title="3.1. 调用ZygoteConnection.runOnce()处理请求"></a>3.1. 调用ZygoteConnection.runOnce()处理请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//读取client端入参列表</span></div><div class="line">    args = readArgumentList();</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pid = -<span class="number">1</span>;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    <span class="comment">//fork进程</span></div><div class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</div><div class="line">            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</div><div class="line">            parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</div><div class="line">            parsedArgs.appDataDir);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// in child</span></div><div class="line">            IoUtils.closeQuietly(serverPipeFd);</div><div class="line">            serverPipeFd = <span class="keyword">null</span>;</div><div class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</div><div class="line"></div><div class="line">            <span class="comment">// should never get here, the child is expected to either</span></div><div class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></div><div class="line">            IoUtils.closeQuietly(childPipeFd);</div><div class="line">            childPipeFd = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        IoUtils.closeQuietly(childPipeFd);</div><div class="line">        IoUtils.closeQuietly(serverPipeFd);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-handleChildProc-与-handleParentProc"><a href="#3-2-handleChildProc-与-handleParentProc" class="headerlink" title="3.2 handleChildProc 与 handleParentProc"></a>3.2 handleChildProc 与 handleParentProc</h3><p>首先来看 handleChildProc，即zygote进程fork出来的子进程执行的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></div><div class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By the time we get here, the native code has closed the two actual Zygote</span></div><div class="line"><span class="comment">     * socket connections, and substituted /dev/null in their place.  The LocalSocket</span></div><div class="line"><span class="comment">     * objects still need to be closed properly.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    </div><div class="line">    <span class="comment">//子进程不再需要处理socket请求，因此关掉两端</span></div><div class="line">    closeSocket();</div><div class="line">    ZygoteInit.closeServerSocket();</div><div class="line">      </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//子进程名字的设置</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</div><div class="line">        Process.setArgV0(parsedArgs.niceName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// End of the postFork event.</span></div><div class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">    <span class="comment">//如果定义了invokeWith参数，则采用 /system/bin/sh这种execShell的方式执行command</span></div><div class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</div><div class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class="line">                VMRuntime.getCurrentInstructionSet(),</div><div class="line">                pipeFd, parsedArgs.remainingArgs);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//否则调用zygoteInit，执行初始化</span></div><div class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</div><div class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</div><div class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</div><div class="line"></div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</div><div class="line">    <span class="comment">//log重定向</span></div><div class="line">    redirectLogStreams();</div><div class="line">    </div><div class="line">    <span class="comment">//通用初始化：default UncaughtExceptionHandler、TimeZone、userAgent、NetworkManagementSocketTagger、trace等等</span></div><div class="line">    commonInit();</div><div class="line">    </div><div class="line">    <span class="comment">//调用frameworks/base/core/jni/AndroidRuntime.cpp</span></div><div class="line">    <span class="comment">//最终调用gCurRuntime-&gt;onZygoteInit，其中gCurRuntime是在zygote进程执行app_main.cpp-&gt;main()时创建的，</span></div><div class="line">    <span class="comment">//而新fork出来的子进程都是基于zygote进程的，因此也会存在该实例</span></div><div class="line">    <span class="comment">//调用AndroidRuntime.onZygoteInit()方法，与binder交互</span></div><div class="line">    nativeZygoteInit();</div><div class="line">    <span class="comment">//应用初始化</span></div><div class="line">    applicationInit(targetSdkVersion, argv, classLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>startThreadPool方法的调用， 参考链接：<a href="http://blog.csdn.net/ganyue803/article/details/41484849" target="_blank" rel="external">http://blog.csdn.net/ganyue803/article/details/41484849</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//binder交互</span></div><div class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</div><div class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</div><div class="line">    <span class="comment">//开启主线程，并与binder 最终talkWithDriver()</span></div><div class="line">    proc-&gt;startThreadPool();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>applicationInit<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</div><div class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></div><div class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></div><div class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></div><div class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></div><div class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></div><div class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></div><div class="line">    <span class="comment">// holding on to a lot of memory that isn't needed.</span></div><div class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</div><div class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Arguments args;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        args = <span class="keyword">new</span> Arguments(argv);</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">        Slog.e(TAG, ex.getMessage());</div><div class="line">        <span class="comment">// let the process exit</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></div><div class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line"></div><div class="line">    <span class="comment">// Remaining arguments are passed to the start class's static main</span></div><div class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</div><div class="line">    Class&lt;?&gt; cl;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</div><div class="line">                ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Method m;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Missing static main on "</span> + className, ex);</div><div class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</div><div class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Main method is not public and static on "</span> + className);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></div><div class="line"><span class="comment">     * by invoking the exception's run() method. This arrangement</span></div><div class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></div><div class="line"><span class="comment">     * up the process.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最终，子进程中，调用invokeStaticMain，抛出ZygoteInit.MethodAndArgsCaller异常，从而跳转到ZygoteInit.main()方法的exception处理中，调用caller.run();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">        Throwable cause = ex.getCause();</div><div class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">            <span class="keyword">throw</span> (RuntimeException) cause;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">            <span class="keyword">throw</span> (Error) cause;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>即，调用ZygoteInit.MethodAndArgsCaller(m, argv)这个main方法，并传参argv</p><p>而对于父进程，也就是我们的zygote进程， 来看看handleParentProc<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleParentProc</span><span class="params">(<span class="keyword">int</span> pid,</span></span></div><div class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, Arguments parsedArgs)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</div><div class="line">        setChildPgid(pid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</div><div class="line">            IoUtils.closeQuietly(fd);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> usingWrapper = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (pipeFd != <span class="keyword">null</span> &amp;&amp; pid &gt; <span class="number">0</span>) &#123;</div><div class="line">        DataInputStream is = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(pipeFd));</div><div class="line">        <span class="keyword">int</span> innerPid = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            innerPid = is.readInt();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"Error reading pid from wrapped process, child may have died"</span>, ex);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                is.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Ensure that the pid reported by the wrapped process is either the</span></div><div class="line">        <span class="comment">// child process that we forked, or a descendant of it.</span></div><div class="line">        <span class="keyword">if</span> (innerPid &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> parentPid = innerPid;</div><div class="line">            <span class="keyword">while</span> (parentPid &gt; <span class="number">0</span> &amp;&amp; parentPid != pid) &#123;</div><div class="line">                parentPid = Process.getParentPid(parentPid);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (parentPid &gt; <span class="number">0</span>) &#123;</div><div class="line">                Log.i(TAG, <span class="string">"Wrapped process has pid "</span> + innerPid);</div><div class="line">                pid = innerPid;</div><div class="line">                usingWrapper = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Log.w(TAG, <span class="string">"Wrapped process reported a pid that is not a child of "</span></div><div class="line">                        + <span class="string">"the process that we forked: childPid="</span> + pid</div><div class="line">                        + <span class="string">" innerPid="</span> + innerPid);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mSocketOutStream.writeInt(pid);</div><div class="line">        mSocketOutStream.writeBoolean(usingWrapper);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"Error writing to command socket"</span>, ex);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>主要做了一些fork清理工作，并没有抛出异常，因此还是在runSelectLoop这个循环中继续往下执行</p><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>至此，整个zygote进程的启动流程执行完毕，主要做了以下事情：</p><ol><li>app_main.cpp -&gt; main()， AppRuntime的初始化：创建虚拟机、注册jni函数</li><li>执行com.android.internal.os.ZygoteInit -&gt; main()函数</li><li>registerZygoteSocket注册服务端sServerSocket</li><li>preload: 基本资源、库的加载</li><li>如果需要启动systemserver，则启动systemserver进程</li><li>runSelectLoop： 进入无限循环，采用poll + socket的机制，等待client端的请求<br>6.1 请求过来，fork进程，并在新的进程中运行class的main方法<br>6.2 父进程做完清理工作，继续在无限循环中执行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从上一篇&lt;a href=&quot;http://molingyu.com/2017/09/26/Android%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)init%E8%BF%9B%E7%A8%8
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://www.molingyu.com/tags/Android/"/>
    
      <category term="源码阅读" scheme="http://www.molingyu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android启动源码阅读(一)init进程的启动</title>
    <link href="http://www.molingyu.com/2017/09/26/Android%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)init%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
    <id>http://www.molingyu.com/2017/09/26/Android启动源码阅读(一)init进程的启动/</id>
    <published>2017-09-25T20:50:02.893Z</published>
    <updated>2017-09-25T20:50:02.893Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统中，Kernel启动完毕之后，启动的第一个用户空间的进程，就是名为<strong>init</strong>的进程：</p><p>以下是查找init进程源码的过程：</p><ol><li><p>查找init进程mk文件位置：</p><p>查找可执行程序：init的编译MODULE定义，即全局查找字符串: LOCAL_MODULE:= init，从而找到mk文件位置system/core/init/Android.mk</p></li><li><p>从MODULE的LOCAL_SRC_FILES找到init.cpp文件</p></li><li><p>全局查找文件(按两次)init.cpp，从而最终找到init.cpp的源码system/core/init/init.cpp</p></li></ol><h1 id="init启动解析-main函数"><a href="#init启动解析-main函数" class="headerlink" title="init启动解析: main函数"></a>init启动解析: main函数</h1><p>作为init可执行文件的入口init.cpp-&gt;main()，我们来看下它是怎么执行的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 将/usr/bin:/bin加入到环境变量中去</span></div><div class="line">    add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--second-stage"</span>) != <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></div><div class="line">    <span class="comment">// on / and then we'll let the rc file figure out the rest.</span></div><div class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</div><div class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</div><div class="line">        mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</div><div class="line">        mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</div><div class="line">        mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></div><div class="line">        mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</div><div class="line">        mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.</span></div><div class="line">    selinux_initialize(is_first_stage);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// These directories were necessarily created before initial policy load</span></div><div class="line">    <span class="comment">// and therefore need their security context restored to the proper value.</span></div><div class="line">    <span class="comment">// This must happen before /dev is populated by ueventd.</span></div><div class="line">    NOTICE(<span class="string">"Running restorecon...\n"</span>);</div><div class="line">    restorecon(<span class="string">"/dev"</span>);</div><div class="line">    restorecon(<span class="string">"/dev/socket"</span>);</div><div class="line">    restorecon(<span class="string">"/dev/__properties__"</span>);</div><div class="line">    restorecon(<span class="string">"/property_contexts"</span>);</div><div class="line">    restorecon_recursive(<span class="string">"/sys"</span>);</div><div class="line"></div><div class="line">    epoll_fd = epoll_create1(EPOLL_CLOEXEC);</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//信号处理handler初始化：通过信号量，管理init fork出来的子进程</span></div><div class="line">    signal_handler_init();</div><div class="line">    <span class="comment">//导入默认boot_property</span></div><div class="line">    property_load_boot_defaults();</div><div class="line">    <span class="comment">//导入oem锁状态</span></div><div class="line">    export_oem_lock_status();</div><div class="line">    <span class="comment">//属性服务初始化</span></div><div class="line">    start_property_service();</div><div class="line">    </div><div class="line">    <span class="comment">//创建内建的函数映射key-func的map集合，Action解析触发都依赖与该map查找对应的函数</span></div><div class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</div><div class="line">    Action::set_function_map(&amp;function_map);</div><div class="line"></div><div class="line">    <span class="comment">//init.rc文件的解析</span></div><div class="line">    Parser&amp; parser = Parser::GetInstance();</div><div class="line">    parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</div><div class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</div><div class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</div><div class="line">    <span class="comment">//开始解析</span></div><div class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</div><div class="line"></div><div class="line">    ActionManager&amp; am = ActionManager::GetInstance();</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// init进程进入该循环</span></div><div class="line">    <span class="comment">// 1. 执行am的命令</span></div><div class="line">    <span class="comment">// 2. 重启相关的process，这里其实是我们通过service启动的子进程</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!waiting_for_exec) &#123;</div><div class="line">            am.ExecuteOneCommand();</div><div class="line">            restart_processes();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> timeout = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span> (process_needs_restart) &#123;</div><div class="line">            timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</div><div class="line">            <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</div><div class="line">                timeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</div><div class="line">            timeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bootchart_sample(&amp;timeout);</div><div class="line">        <span class="comment">//阻塞，等待新的command的到来</span></div><div class="line">        epoll_event ev;</div><div class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</div><div class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</div><div class="line">            ERROR(<span class="string">"epoll_wait failed: %s\n"</span>, strerror(errno));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</div><div class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>总结下来，init进程做了几件事情：</p><ol><li>bin环境变量的添加</li><li>所需的文件系统的挂载</li><li>信号处理、oem锁、属性服务启动</li><li>init.rc文件的解析</li><li>进入循环，通过ActionManager开始执行Command</li><li>restart_processes，重新启动process，如果有必要的话</li></ol><p>本文，我们只关注两点：</p><ol><li>rc文件的解析</li><li>restart_processes 启动新的process</li></ol><h2 id="init-rc文件的解析过程"><a href="#init-rc文件的解析过程" class="headerlink" title="init.rc文件的解析过程"></a>init.rc文件的解析过程</h2><p>init.rc文件位于system/core/rootdir/init.rc</p><h3 id="rc文件的变化"><a href="#rc文件的变化" class="headerlink" title="rc文件的变化"></a>rc文件的变化</h3><p>在 7.+ 版本的系统中，rc文件的内容根据具体的模块拆分成不同的rc文件，</p><p>比如init.rc文件的头部:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import /init.environ.rc</div><div class="line">import /init.usb.rc</div><div class="line">import /init.$&#123;ro.hardware&#125;.rc</div><div class="line">import /init.usb.configfs.rc</div><div class="line">import /init.$&#123;ro.zygote&#125;.rc</div></pre></td></tr></table></figure></p><p>又比如servicemanager的初始化： frameworks/native/cmds/servicemanager/servicemanager.rc</p><p>参考链接：<a href="http://blog.csdn.net/sunao2002002/article/details/52454878" target="_blank" rel="external">http://blog.csdn.net/sunao2002002/article/details/52454878</a></p><h3 id="解析源码段分析"><a href="#解析源码段分析" class="headerlink" title="解析源码段分析"></a>解析源码段分析</h3><p>先来看看代码段<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Parser&amp; parser = Parser::GetInstance();</div><div class="line">parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</div><div class="line">parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</div><div class="line">parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</div><div class="line">parser.ParseConfig(<span class="string">"/init.rc"</span>);</div></pre></td></tr></table></figure></p><ol><li><p>Parser是一个单例，全局字符串查找 Parser::GetInstance，即可找到定义位置system/core/init/init_parser.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Parser&amp; Parser::GetInstance() &#123;</div><div class="line">    <span class="keyword">static</span> Parser instance;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用AddSectionParser将几个解析器放置到map中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parser::AddSectionParser(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</div><div class="line">                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SectionParser&gt; parser) &#123;</div><div class="line">    section_parsers_[name] = <span class="built_in">std</span>::move(parser);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>开始解析:<code>parser.ParseConfig(&quot;/init.rc&quot;);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Parser::ParseConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</div><div class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</div><div class="line">        <span class="keyword">return</span> ParseConfigDir(path);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ParseConfigFile(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>由于传入的”/init.rc”是一个文件，因此开始<code>ParseConfigFile(path)</code>解析</p><ol><li>file解析<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Parser::ParseConfigFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</div><div class="line">    INFO(<span class="string">"Parsing file %s...\n"</span>, path.c_str());</div><div class="line">    Timer t;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data;</div><div class="line">    <span class="comment">//将file内容读入data字符串中</span></div><div class="line">    <span class="keyword">if</span> (!read_file(path.c_str(), &amp;data)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//内容字符串修正</span></div><div class="line">    data.push_back(<span class="string">'\n'</span>); <span class="comment">// <span class="doctag">TODO:</span> fix parse_config.</span></div><div class="line">    <span class="comment">//4.1 解析文件内容</span></div><div class="line">    ParseData(path, data);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sp : section_parsers_) &#123;</div><div class="line">        <span class="comment">//4.2 解析文件完毕</span></div><div class="line">        sp.second-&gt;EndFile(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Turning this on and letting the INFO logging be discarded adds 0.2s to</span></div><div class="line">    <span class="comment">// Nexus 9 boot time, so it's disabled by default.</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) DumpState();</div><div class="line"></div><div class="line">    NOTICE(<span class="string">"(Parsing %s took %.2fs.)\n"</span>, path.c_str(), t.duration());</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="ParseData-解析说明"><a href="#ParseData-解析说明" class="headerlink" title="ParseData()解析说明"></a>ParseData()解析说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Parser::ParseData(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data) &#123;</div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span> Use a parser with const input and remove this copy</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; data_copy(data.begin(), data.end());</div><div class="line">    data_copy.push_back(<span class="string">'\0'</span>);</div><div class="line">    <span class="comment">//初始化解析参数</span></div><div class="line">    parse_state state;</div><div class="line">    state.filename = filename.c_str();</div><div class="line">    state.line = <span class="number">0</span>;</div><div class="line">    state.ptr = &amp;data_copy[<span class="number">0</span>];</div><div class="line">    state.nexttoken = <span class="number">0</span>;</div><div class="line">    <span class="comment">//解析器</span></div><div class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</div><div class="line">    <span class="comment">//解析出来的参数存放位置</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">//next_token()：真正解析文件的地方</span></div><div class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</div><div class="line">        <span class="keyword">case</span> T_EOF:</div><div class="line">            <span class="comment">//解析到文件末尾</span></div><div class="line">            <span class="keyword">if</span> (section_parser) &#123;</div><div class="line">                section_parser-&gt;EndSection();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">case</span> T_NEWLINE:</div><div class="line">            <span class="comment">//新行</span></div><div class="line">            state.line++;</div><div class="line">            <span class="keyword">if</span> (args.empty()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</div><div class="line">                <span class="comment">//新的一行开始，如果此前的section_parser不为空，则结束那一行的解析：EndSection</span></div><div class="line">                <span class="keyword">if</span> (section_parser) &#123;</div><div class="line">                    section_parser-&gt;EndSection();</div><div class="line">                &#125;</div><div class="line">                section_parser = section_parsers_[args[<span class="number">0</span>]].get();</div><div class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</div><div class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123;</div><div class="line">                    parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</div><div class="line">                    section_parser = <span class="literal">nullptr</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</div><div class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</div><div class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseLineSection(args, state.filename,</div><div class="line">                                                      state.line, &amp;ret_err)) &#123;</div><div class="line">                    parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            args.clear();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> T_TEXT:</div><div class="line">            <span class="comment">//解析到字符串内容：例如 service zygote /system/bin/app_process</span></div><div class="line">            <span class="comment">//则解析到的结果是args=&#123;"service", "zygote", "/system/bin/app_process"&#125;</span></div><div class="line">            args.emplace_back(state.text);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>GetInstance</p><h3 id="举例说明解析过程"><a href="#举例说明解析过程" class="headerlink" title="举例说明解析过程"></a>举例说明解析过程</h3><ol><li>读取init.rc文件时，遇到import语句，因此args[0] = “import”，采用ImportParser进行解析</li><li><p>调用ImportParser-&gt;ParseSection进行解析：args={“import”, “/init.${ro.zygote}.rc”}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> ImportParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</div><div class="line">                                <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</div><div class="line">    <span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</div><div class="line">        *err = <span class="string">"single argument needed for import\n"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> conf_file;</div><div class="line">    <span class="comment">//通过expand_props将$&#123;ro.zygote&#125;替换成对应平台的实现，例如zygote32，因此文件名为：init.zygote32.rc</span></div><div class="line">    <span class="keyword">bool</span> ret = expand_props(args[<span class="number">1</span>], &amp;conf_file);</div><div class="line">    <span class="keyword">if</span> (!ret) &#123;</div><div class="line">        *err = <span class="string">"error while expanding import"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INFO(<span class="string">"Added '%s' to import list\n"</span>, conf_file.c_str());</div><div class="line">    <span class="comment">//将解析出来，import的真正文件名放到imports_列表中</span></div><div class="line">    imports_.emplace_back(<span class="built_in">std</span>::move(conf_file));</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>回到Parser::ParseConfigFile，当文件解析完毕之后，调用所有的Parser-&gt;EndFile</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sp : section_parsers_) &#123;</div><div class="line">    <span class="comment">//4.2 解析文件完毕</span></div><div class="line">    sp.second-&gt;EndFile(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>因此，我们看下ImportParser-&gt;EndFile():<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ImportParser::EndFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename) &#123;</div><div class="line">    <span class="keyword">auto</span> current_imports = <span class="built_in">std</span>::move(imports_);</div><div class="line">    imports_.clear();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : current_imports) &#123;</div><div class="line">        <span class="keyword">if</span> (!Parser::GetInstance().ParseConfig(s)) &#123;</div><div class="line">            ERROR(<span class="string">"could not import file '%s' from '%s': %s\n"</span>,</div><div class="line">                  s.c_str(), filename.c_str(), strerror(errno));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由此可见，又针对每个文件，进行了Parser::GetInstance().ParseConfig(s)解析</p><ol><li><p>imprt进来的file的解析步骤仍然走的：</p><ul><li>Parser::ParseConfig</li><li>Parser::ParseConfigFile</li><li>循环1. Parser::ParseData</li><li>循环2. system/core/init/parser.cpp-&gt;next_token()</li><li>循环3. Parser::ParseSection</li><li>循环4. Parser::EndSection</li></ul></li><li><p>我们来看service的解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</div><div class="line">    class main</div><div class="line">    socket zygote stream 660 root system</div><div class="line">    onrestart write /sys/android_power/request_state wake</div><div class="line">    onrestart write /sys/power/state on</div><div class="line">    onrestart restart audioserver</div><div class="line">    onrestart restart cameraserver</div><div class="line">    onrestart restart media</div><div class="line">    onrestart restart netd</div><div class="line">    writepid /dev/cpuset/foreground/tasks</div></pre></td></tr></table></figure><ol><li>在ParserData()的时候，args[0]=”service”，采用ServiceParser进行解析<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> ServiceParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</div><div class="line">                                 <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</div><div class="line">    <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</div><div class="line">        *err = <span class="string">"services must have a name and a program"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span> (!IsValidName(name)) &#123;</div><div class="line">        *err = StringPrintf(<span class="string">"invalid service name '%s'"</span>, name.c_str());</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str_args(args.begin() + <span class="number">2</span>, args.end());</div><div class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, <span class="string">"default"</span>, str_args);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>由此可见，service关键字的解析，将会创建Service对象，并赋值给ServiceParser的service_成员</p><ol><li>当这一行解析完毕之后，进入下一行，由于下一行的args[0]不为{“service”，”on”,”import”}中的任意一个，因此进入解析方法ParseLineSection <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> ServiceParser::ParseLineSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line, <span class="built_in">std</span>::<span class="built_in">string</span>* err) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> service_ ? service_-&gt;HandleLine(args, err) : <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>HandleLine方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Service::HandleLine(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</div><div class="line">    <span class="keyword">if</span> (args.empty()) &#123;</div><div class="line">        *err = <span class="string">"option needed, but not provided"</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据OptionHandlerMap,找寻args[0]所对应的函数</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> OptionHandlerMap handler_map;</div><div class="line">    <span class="keyword">auto</span> handler = handler_map.FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!handler) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//找到args[0]对应的方法，调用该方法，并将方法的返回值true/false，</span></div><div class="line">    <span class="comment">//返回: 这些方法基本上都是service_的属性设置，返回的都是boolean值</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*handler)(args, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>//OptionHandlerMap定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map option_handlers = &#123;</div><div class="line">        &#123;<span class="string">"class"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleClass&#125;&#125;,</div><div class="line">        &#123;<span class="string">"console"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleConsole&#125;&#125;,</div><div class="line">        &#123;<span class="string">"critical"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleCritical&#125;&#125;,</div><div class="line">        &#123;<span class="string">"disabled"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleDisabled&#125;&#125;,</div><div class="line">        &#123;<span class="string">"group"</span>,       &#123;<span class="number">1</span>,     NR_SVC_SUPP_GIDS + <span class="number">1</span>, &amp;Service::HandleGroup&#125;&#125;,</div><div class="line">        &#123;<span class="string">"ioprio"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleIoprio&#125;&#125;,</div><div class="line">        &#123;<span class="string">"keycodes"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleKeycodes&#125;&#125;,</div><div class="line">        &#123;<span class="string">"oneshot"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleOneshot&#125;&#125;,</div><div class="line">        &#123;<span class="string">"onrestart"</span>,   &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleOnrestart&#125;&#125;,</div><div class="line">        &#123;<span class="string">"seclabel"</span>,    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleSeclabel&#125;&#125;,</div><div class="line">        &#123;<span class="string">"setenv"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleSetenv&#125;&#125;,</div><div class="line">        &#123;<span class="string">"socket"</span>,      &#123;<span class="number">3</span>,     <span class="number">6</span>,    &amp;Service::HandleSocket&#125;&#125;,</div><div class="line">        &#123;<span class="string">"user"</span>,        &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleUser&#125;&#125;,</div><div class="line">        &#123;<span class="string">"writepid"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleWritepid&#125;&#125;,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> option_handlers;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>当所有的Line解析完毕，到达文件末尾，则调用ServiceParser::EndSection方法:<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ServiceParser::EndSection() &#123;</div><div class="line">    <span class="keyword">if</span> (service_) &#123;</div><div class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>将刚才解析的service_成员,move到ServiceManager的列表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ServiceManager::AddService(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Service&gt; service) &#123;</div><div class="line">    Service* old_service = FindServiceByName(service-&gt;name());</div><div class="line">    <span class="keyword">if</span> (old_service) &#123;</div><div class="line">        ERROR(<span class="string">"ignored duplicate definition of service '%s'"</span>,</div><div class="line">              service-&gt;name().c_str());</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    services_.emplace_back(<span class="built_in">std</span>::move(service));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>至此，init.zygote32.rc文件解析完毕</li></ol></li></ol><h3 id="restart-processes"><a href="#restart-processes" class="headerlink" title="restart_processes"></a>restart_processes</h3><p>前面分析init.cpp-&gt;main()函数的时候，在while循环中，调用了restart_processes方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_processes</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    process_needs_restart = <span class="number">0</span>;</div><div class="line">    ServiceManager::GetInstance().</div><div class="line">        ForEachServiceWithFlags(SVC_RESTARTING, [] (Service* s) &#123;</div><div class="line">                s-&gt;RestartIfNeeded(process_needs_restart);</div><div class="line">            &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> ServiceManager::ForEachServiceWithFlags(<span class="keyword">unsigned</span> matchflags,</div><div class="line">                                             <span class="keyword">void</span> (*func)(Service* svc)) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : services_) &#123;</div><div class="line">        <span class="keyword">if</span> (s-&gt;flags() &amp; matchflags) &#123;</div><div class="line">            func(s.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从代码看到，这段代码对每一个Service，都进行了调用函数调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">：s-&gt;RestartIfNeeded(process_needs_restart);</div></pre></td></tr></table></figure></p><p>因此，最终调用到了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Service::RestartIfNeeded(<span class="keyword">time_t</span>&amp; process_needs_restart) &#123;</div><div class="line">    <span class="keyword">time_t</span> next_start_time = time_started_ + <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next_start_time &lt;= gettime()) &#123;</div><div class="line">        flags_ &amp;= (~SVC_RESTARTING);</div><div class="line">        Start();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((next_start_time &lt; process_needs_restart) ||</div><div class="line">        (process_needs_restart == <span class="number">0</span>)) &#123;</div><div class="line">        process_needs_restart = next_start_time;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="调用到了Service-Start-方法-system-core-init-service-cpp"><a href="#调用到了Service-Start-方法-system-core-init-service-cpp" class="headerlink" title="调用到了Service:Start()方法: system/core/init/service.cpp"></a>调用到了Service:Start()方法: system/core/init/service.cpp</h3><p>这段代码比较长，就不贴了，列举几个重要的片段：</p><ul><li><p>fork一个新的进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pid_t</span> pid = fork();</div></pre></td></tr></table></figure></li><li><p>在新的进程中，如果sockets_不为空，就创建socket:  此处init.zygote32.rc文件中，socket zygote stream 660 root system</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; si : sockets_) &#123;</div><div class="line">    <span class="keyword">int</span> socket_type = ((si.type == <span class="string">"stream"</span> ? SOCK_STREAM :</div><div class="line">                        (si.type == <span class="string">"dgram"</span> ? SOCK_DGRAM :</div><div class="line">                         SOCK_SEQPACKET)));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* socketcon =</div><div class="line">        !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> s = create_socket(si.name.c_str(), socket_type, si.perm,</div><div class="line">                          si.uid, si.gid, socketcon);</div><div class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//调用PublishSocket，将si.name=zygote，设置到环境变量"ANDROID_SOCKET_ENV_PREFIX si.name"中去</span></div><div class="line">        PublishSocket(si.name, s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终通过execve来执行 /system/bin/app_process</span></div><div class="line"><span class="keyword">if</span> (execve(strs[<span class="number">0</span>], (<span class="keyword">char</span>**) &amp;strs[<span class="number">0</span>], (<span class="keyword">char</span>**) ENV) &lt; <span class="number">0</span>) &#123;</div><div class="line">    ERROR(<span class="string">"cannot execve('%s'): %s\n"</span>, strs[<span class="number">0</span>], strerror(errno));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Service::PublishSocket(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> fd) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = StringPrintf(ANDROID_SOCKET_ENV_PREFIX <span class="string">"%s"</span>, name.c_str());</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> val = StringPrintf(<span class="string">"%d"</span>, fd);</div><div class="line">    add_environment(key.c_str(), val.c_str());</div><div class="line"></div><div class="line">    <span class="comment">/* make sure we don't close-on-exec */</span></div><div class="line">    fcntl(fd, F_SETFD, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此会创建一个名为zygote的socket，挂在在/dev/socket/zygote节点下，</p><p>最终通过execve来执行 /system/bin/app_process</p><p>至此，一个service进程就解析，并创建进程，在新进程中开始执行</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>上述分析，仅仅针对service关键字做了分析，其他的关键字on、class等等，同理分析</p><p>参考资料:</p><ul><li><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="external">http://gityuan.com/2016/02/05/android-init/</a></li><li><a href="http://blog.csdn.net/A8316124/article/details/62224237" target="_blank" rel="external">http://blog.csdn.net/A8316124/article/details/62224237</a></li><li><a href="http://blog.csdn.net/sunao2002002/article/details/52454878" target="_blank" rel="external">http://blog.csdn.net/sunao2002002/article/details/52454878</a></li><li>system/core/init/readme.txt</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux系统中，Kernel启动完毕之后，启动的第一个用户空间的进程，就是名为&lt;strong&gt;init&lt;/strong&gt;的进程：&lt;/p&gt;
&lt;p&gt;以下是查找init进程源码的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查找init进程mk文件位置：&lt;/p&gt;
&lt;p&gt;查找可执行程
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://www.molingyu.com/tags/Android/"/>
    
      <category term="源码阅读" scheme="http://www.molingyu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android源码阅读准备</title>
    <link href="http://www.molingyu.com/2017/09/25/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.molingyu.com/2017/09/25/Android源码阅读技巧/</id>
    <published>2017-09-25T14:34:15.387Z</published>
    <updated>2017-09-25T14:34:15.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>参考<a href="https://source.android.com/source/downloading" target="_blank" rel="external">官方doc</a>，需要自备梯子</p><h2 id="选定分支"><a href="#选定分支" class="headerlink" title="选定分支"></a>选定分支</h2><p>我自己的是Nexus6，写这篇日志时，当前官网适配的最新版本是 7.1.1_r45，因此我的源码编译和阅读都是基于这个分支，手机上也是运行的这个版本。</p><h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><ul><li><strong>Windows</strong> : Source Insight，跟踪代码的一大利器</li><li><strong>Linux</strong> : wine + Source Insight，各种问题，够折腾</li><li><strong>Linux</strong> : AndroidStudio，各种java索引跳转溜溜的，除了native代码</li></ul><p>因此，我采用了<a href="http://blog.csdn.net/yanbober/article/details/48846331" target="_blank" rel="external"><strong>AndroidStudio导入Android源码</strong></a>的方式来浏览源码</p><p>这样唯一一个问题就是native代码的阅读，需要自己手动全局查找:</p><blockquote><p>1.查找某个类：Ctrl + Shift + F，然后输入类名称，比如查找native的Looper类，可以通过全局搜索” Looper {“，来定位到类定义位置。</p><p>2.查找某个方法: Ctrl + Shift + F， </p><ul><li>方法名</li><li>方法名 + {</li><li>正则表达式：” “ + 方法名 + [(] (.*) [)] + [\n] + [{]</li><li>某个类中的某个方法，直接搜: “ “ + 方法名 + “(“</li><li>有些方法是类定义的C++方法，可以采用:  “::” + 方法名， 的方式来搜索</li></ul><p>3.查找某个文件: Ctrl + Shift + N（或者按两次）, 输入文件名，如果有多个匹配，需要谨慎选择，通常情况下都是优先匹配到的第一个文件。</p></blockquote><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>如此，我们就可以遨游在AndroidSource的海洋里了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://source.android.com/source/downloading" target="_blank" rel="external">https://source.android.com/source/downloading</a><br><a href="http://blog.csdn.net/yanbober/article/details/48846331" target="_blank" rel="external">http://blog.csdn.net/yanbober/article/details/48846331</a><br><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="external">http://www.runoob.com/regexp/regexp-syntax.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码下载&quot;&gt;&lt;a href=&quot;#源码下载&quot; class=&quot;headerlink&quot; title=&quot;源码下载&quot;&gt;&lt;/a&gt;源码下载&lt;/h2&gt;&lt;p&gt;参考&lt;a href=&quot;https://source.android.com/source/downloading&quot; targ
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://www.molingyu.com/tags/Android/"/>
    
      <category term="源码阅读" scheme="http://www.molingyu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>一个epoll实例</title>
    <link href="http://www.molingyu.com/2017/09/18/%E4%B8%80%E4%B8%AAepoll%E5%AE%9E%E4%BE%8B/"/>
    <id>http://www.molingyu.com/2017/09/18/一个epoll实例/</id>
    <published>2017-09-18T06:07:49.490Z</published>
    <updated>2017-09-18T06:07:49.490Z</updated>
    
    <content type="html"><![CDATA[<p>epoll 于Linux 2.5.44引入，旨在替换select和poll系统函数。</p><p>相对于select和poll来说，epoll更加灵活高效:</p><ul><li>没有监视描述符数量单进程1024限制</li><li>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</li></ul><h2 id="epoll在Android中的应用"><a href="#epoll在Android中的应用" class="headerlink" title="epoll在Android中的应用"></a>epoll在Android中的应用</h2><p>epoll机制在Android系统中扮演着一个很重要的角色，</p><ol><li>在MessageQueue的队列中，当队列为空时需要阻塞Looper线程，队列非空时候需要唤醒线程，使用到了epoll + eventfd(比pipe更高效的事件驱动，在<a href="https://android.googlesource.com/platform/system/core/+/8892ce6%5E!/" target="_blank" rel="external">6.0引入</a>)机制，高效的管理着消息队列</li><li>java NIO中 Selector采用了epoll机制实现SocketChannel管道事件轮询</li></ol><h2 id="实例代码（采用epoll-pipe实现）"><a href="#实例代码（采用epoll-pipe实现）" class="headerlink" title="实例代码（采用epoll + pipe实现）"></a>实例代码（采用epoll + pipe实现）</h2><p>本例我们采用 epoll + pipe的机制，简单的模拟一个通信唤醒的场景来理解epoll通信，更深入的理解，可以阅读libevent源码</p><ol><li>创建管道</li><li>创建epll事件：并设置关注的事件类型</li><li>创建epoll</li><li>往epoll注册事件</li><li>fork一个子进程，sleep(3)秒后，往管道写入数据</li><li>父进程挂起，监听事件源(管道读取端fd)事件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//最大事件数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXEVENTS = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 1. 创建管道，并将管道两端的fd存放在数组pipe_fd中</span></div><div class="line"><span class="comment">     * pipe_fd[0] ： 管道输出端，可读取fd</span></div><div class="line"><span class="comment">     * pipe_fd[1] ： 管道输入端，可写入fd</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">if</span> ((ret = pipe(pipe_fd)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"create pipe fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 2. 创建epoll关注事件源的事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></div><div class="line">    <span class="comment">//设置监听事件源</span></div><div class="line">    ev.data.fd = pipe_fd[<span class="number">0</span>];</div><div class="line">    <span class="comment">//设置监听什么事件：EPOLLIN, 事件源可读事件， EPOLLET 边缘触发模式(Edge Triggered)</span></div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 3. 创建epoll对象，返回epoll对象的fd地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(MAXEVENTS);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 4. 往epoll对象中 添加/修改/删除 一个事件(事件源fd, 事件类型&amp;ev)</span></div><div class="line"><span class="comment">     * EPOLL_CTL_ADD：注册新的fd到epfd中；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_DEL：从epfd中删除一个fd；</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev);</div><div class="line">    <span class="comment">//校验</span></div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_ctl fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fork一个进程，来读取epoll事件</span></div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></div><div class="line">        <span class="comment">//监听事件数组</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 6. 使用epoll，开始监听事件，并将事件放置到数组events中</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * epoll_wait会阻塞当前线程，当监听的事件发生的时候，会唤醒该线程</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">int</span> count = epoll_wait(epfd, events, MAXEVENTS, <span class="number">5000</span>);</div><div class="line">        <span class="keyword">char</span> r_buf[<span class="number">100</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="comment">//校验</span></div><div class="line">            <span class="keyword">if</span> ((events[i].data.fd == pipe_fd[<span class="number">0</span>]) &amp;&amp; (events[<span class="number">0</span>].events &amp; EPOLLIN)) &#123;</div><div class="line">                <span class="keyword">int</span> r_num = read(pipe_fd[<span class="number">0</span>], r_buf, <span class="number">100</span>);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"parrent read num is %d bytes data from the pipe, value is %d \n"</span>, r_num, atoi(r_buf));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent close read fd[0], wirte fd[1] and epfd over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//子进程</span></div><div class="line">        <span class="comment">//子进程不进行读取操作，关闭读取fd</span></div><div class="line">        close(pipe_fd[<span class="number">0</span>]);<span class="comment">//read</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sub does't read, so close read fd[0], over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">        <span class="comment">//当前线程睡眠3秒</span></div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 5. 子进程开始向管道写入数据，触发EPOLLIN事件</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">char</span> w_buf[<span class="number">100</span>];</div><div class="line">        <span class="built_in">strcpy</span>(w_buf, <span class="string">"1234"</span>);</div><div class="line">        <span class="keyword">if</span> (write(pipe_fd[<span class="number">1</span>], w_buf, <span class="number">5</span>) != <span class="number">-1</span>)<span class="comment">//you can remove this line for learn</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"sub write write num 1234, over \n"</span>);</div><div class="line">        <span class="comment">//关闭写入端管道fd</span></div><div class="line">        close(pipe_fd[<span class="number">1</span>]);<span class="comment">//write</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub close write fd[1] over \n"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//pid&lt;0, fork error</span></div><div class="line">        close(pipe_fd[<span class="number">0</span>]);</div><div class="line">        close(pipe_fd[<span class="number">1</span>]);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error:"</span> &lt;&lt; pid &lt;&lt; <span class="string">", close fds over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="改用epoll-eventfd来实现"><a href="#改用epoll-eventfd来实现" class="headerlink" title="改用epoll + eventfd来实现"></a>改用epoll + eventfd来实现</h2><p>eventfd在2.6.22引入，是比pipe更高效的线程间事件通知机制，它的缓冲区只有8个字节。</p><p>eventfd 只能用于线程间、父子进程间的通信</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Created by milo on 17-9-18.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXEVENTS = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * eventfd (unsigned int __count, int __flags)</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * man: http://man7.org/linux/man-pages/man2/eventfd.2.html</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * initval: eventfd设备初始值</span></div><div class="line"><span class="comment">     * flags: 在2.6.26之前的版本，必须设置为0，之后的版本有以下值：</span></div><div class="line"><span class="comment">     *     EFD_SEMAPHORE</span></div><div class="line"><span class="comment">     *     EFD_CLOEXEC</span></div><div class="line"><span class="comment">     *     EFD_NONBLOCK</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 1. 创建epoll关注事件源的事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></div><div class="line">    <span class="comment">//设置监听事件源</span></div><div class="line">    ev.data.fd = efd;</div><div class="line">    <span class="comment">//设置监听什么事件：EPOLLIN, 事件源可读事件， EPOLLET 边缘触发模式(Edge Triggered)</span></div><div class="line">    ev.events = EPOLLIN | EPOLLET;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 2. 创建epoll对象，返回epoll对象的fd地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> epfd = epoll_create(MAXEVENTS);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 3. 往epoll对象中 添加/修改/删除 一个事件(事件源fd, 事件类型&amp;ev)</span></div><div class="line"><span class="comment">     * EPOLL_CTL_ADD：注册新的fd到epfd中；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</span></div><div class="line"><span class="comment">     * EPOLL_CTL_DEL：从epfd中删除一个fd；</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, efd, &amp;ev);</div><div class="line">    <span class="comment">//校验</span></div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"epoll_ctl fail:"</span> &lt;&lt; ret &lt;&lt; <span class="string">",errno:"</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fork一个进程，来读取epoll事件</span></div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">//父进程</span></div><div class="line">        <span class="comment">//监听事件数组</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAXEVENTS</span>];</span></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 4. 使用epoll，开始监听事件源，并将事件放置到数组events中</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * epoll_wait会阻塞当前线程，当监听的事件发生的时候，会唤醒该线程</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">int</span> count = epoll_wait(epfd, events, MAXEVENTS, <span class="number">5000</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            <span class="comment">//校验</span></div><div class="line">            <span class="keyword">if</span> ((events[i].data.fd == efd) &amp;&amp; (events[<span class="number">0</span>].events &amp; EPOLLIN)) &#123;</div><div class="line">                <span class="keyword">eventfd_t</span> r_num;</div><div class="line">                <span class="keyword">ssize_t</span> size = read(efd, &amp;r_num, <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>));</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"parrent read num is %d bytes data from the eventfd, value is %d \n"</span>, size, r_num);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent close eventfd and epfd over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//子进程</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub sleep 3 senconds, and then write\n"</span>);</div><div class="line">        flush(<span class="built_in">cout</span>);</div><div class="line">        <span class="comment">//当前线程睡眠3秒</span></div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">        <span class="comment">//子进程开始向eventfd设备写入数据</span></div><div class="line">        <span class="keyword">eventfd_t</span> num = <span class="number">18</span>;</div><div class="line">        <span class="keyword">if</span> (write(efd, &amp;num, <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>)) == <span class="keyword">sizeof</span>(<span class="keyword">eventfd_t</span>))<span class="comment">//you can remove this line for learn</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"sub write num %d, over \n"</span>, num);</div><div class="line">        <span class="comment">//关闭子进程eventfd</span></div><div class="line">        close(efd);<span class="comment">//write</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"sub close write eventfd over \n"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//pid&lt;0, fork error</span></div><div class="line">        close(efd);</div><div class="line">        close(epfd);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"fork error:"</span> &lt;&lt; pid &lt;&lt; <span class="string">", close fds over"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://aceld.gitbooks.io/libevent/content/" target="_blank" rel="external">Libevent深入浅出</a><br><br><a href="http://blog.csdn.net/u010657219/article/details/44061629" target="_blank" rel="external">实现机制详解</a><br><br><a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="external">IO多路复用之epoll总结</a><br><br><a href="http://yaocoder.blog.51cto.com/2668309/888374" target="_blank" rel="external">我读过的最好的epoll讲解–转自”知乎“</a><br><br><a href="http://man7.org/linux/man-pages/man2/eventfd.2.html" target="_blank" rel="external">man2:eventfd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;epoll 于Linux 2.5.44引入，旨在替换select和poll系统函数。&lt;/p&gt;
&lt;p&gt;相对于select和poll来说，epoll更加灵活高效:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有监视描述符数量单进程1024限制&lt;/li&gt;
&lt;li&gt;epoll使用一个文件描述符管理
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://www.molingyu.com/tags/Linux/"/>
    
      <category term="C/C++" scheme="http://www.molingyu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>本博客的建立</title>
    <link href="http://www.molingyu.com/2017/09/17/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>http://www.molingyu.com/2017/09/17/本博客的建立/</id>
    <published>2017-09-16T18:11:22.717Z</published>
    <updated>2017-09-16T18:11:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>白驹过隙，工作已有6个春秋</p><p>回望时，竟然没留下些什么</p><p>或心情、或笔录、或歌词、或曲调、或技术历程</p><p>不免感慨万分</p><p>当我老了，至少在这世间留下些什么文字，孤芳自赏也好</p><h2 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h2><ul><li>从开始学习Java的时候，曾开博客，将java的课本的知识点一一以自己的理解记录下来</li><li>然后自从工作以来，就渐渐不再更新博客，以至于原博客杂草丛生，无人问津，甚至密码都忘记，那会是在csdn，用的邮箱还是yahoo.com.cn，然后就gg了，再也找不回账号了</li><li>现如今，技术成长和技术驱动，俨然已经跟不上脚步，然年近中年，危机四伏</li><li>写博客作为一种重要的学以致用、朝闻夕记的重要手段，不能荒废丢弃</li><li>以前的学习记录，是该定期整理成文，来督促自己去复习管理</li></ul><h2 id="如何写博客"><a href="#如何写博客" class="headerlink" title="如何写博客"></a>如何写博客</h2><p>本博客的博文</p><ul><li>尽自己所能，还原事物本质</li><li>周期性成文，不可懈怠</li><li>前路漫漫，与君共勉</li></ul><h2 id="如何建立站点"><a href="#如何建立站点" class="headerlink" title="如何建立站点"></a>如何建立站点</h2><p>这个部分，网上已经许多文章</p><ul><li><a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/setup.html</a> </li><li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/</a></li><li><a href="https://github.com/limedroid/HexoLearning" target="_blank" rel="external">https://github.com/limedroid/HexoLearning</a></li></ul><p>我这里主要是提一下npm install遇到的代理问题，很多插件的安装，遇到国墙无法安装，我们需要给npm设置代理才行,<br><a href="https://segmentfault.com/a/1190000002589144" target="_blank" rel="external">参考链接</a>。</p><p>我使用的是Lantern代理，代理的ip和端口，可以从Lanter主页面的Settings的Advance Settins中查看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP(S) proxy : 127.0.0.1:35937</div><div class="line">SOCKS proxy   : 127.0.0.1:38185</div></pre></td></tr></table></figure></p><p>因此，在设置代理的时候，采用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set proxy http://127.0.0.1:35937</div><div class="line">npm config set https-proxy http://127.0.0.1:35937</div></pre></td></tr></table></figure></p><p>后续的插件安装, hexo部署，都能够很顺利的访问</p><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>路漫漫其修远兮，吾将上下而求索 —— 屈原《离骚》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;白驹过隙，工作已有6个春秋&lt;/p&gt;
&lt;p&gt;回望时，竟然没留下些什么&lt;/p&gt;
&lt;p&gt;或心情、或笔录、或歌词、或曲调、或技术历程&lt;/p&gt;
&lt;p&gt;不免感慨万分&lt;/p&gt;
&lt;p&gt;当我老了，至少在这世间留下些什么文字，孤芳自赏也好&lt;/p&gt;
&lt;h2 id=&quot;为什么要写博客&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.molingyu.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://www.molingyu.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://www.molingyu.com/2017/09/17/ReentrantLock/"/>
    <id>http://www.molingyu.com/2017/09/17/ReentrantLock/</id>
    <published>2017-09-16T18:11:19.429Z</published>
    <updated>2017-09-16T18:11:19.429Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。</p><p>ReentrantLock是Java并发包中互斥锁，它有公平锁和非公平锁两种实现方式，默认构造函数采用非公平锁的方式实现。</p><a id="more"></a><h2 id="lock流程"><a href="#lock流程" class="headerlink" title="lock流程"></a>lock流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认非公平锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据fair来初始化使用哪种锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用FairSync或者NonfairSync的lock方法，默认sync=NonfairSync</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 首先会通过CAS方法，尝试将当前的java.util.concurrent.locks.AbstractQueuedSynchronizer#state中的state字段改成从0改成1</span></div><div class="line"><span class="comment">/*  </span></div><div class="line"><span class="comment">  NonfairSync 继承于 AbstractQueuedSynchronizer， AQS有volatile字段state如下：</span></div><div class="line"><span class="comment">  private volatile int state;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//2. 如果修改成功，则state锁加锁成功，然后将当前线程通过setExclusiveOwnerThread设置为NonfairSync的独占线程</span></div><div class="line"></div><div class="line"><span class="comment">//3. 否则，就像普通线程一样，acquire(1)， 请求加锁</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//aquire(1)方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4. 在tryAcquire(1)中调用nonfairTryAcquire(1)</span></div><div class="line"><span class="comment">//4.1 获取AQS的 state</span></div><div class="line"><span class="comment">//4.1.1 如果c==0,则说明AQS没有加锁，就开始进行CAS操作，成功的化话就setExclusiveOwnerThread，返回true</span></div><div class="line"><span class="comment">//4.1.2 如果c!=0， 则检查当前线程释放为AQS的独占线程，如果是，则int nextc = c + acquires;将state + 1，然后setState(nextc)，并返回true</span></div><div class="line"><span class="comment">//否则返回false</span></div><div class="line"><span class="comment">//PS: 这里的CAS操作，是调用Unsafe类的compareAndSwapInt通过native直接郊游系统操作CPU完成的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5. 如果4的!tryAcquire()成立，即tryAcquire失败，则开始 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span></div><div class="line"><span class="comment">//5.1 首先 addWaiter(Node.EXCLUSIVE)，将当前线程添加到AQS的队列中:</span></div><div class="line"><span class="comment">//(1)首先创建一个为独占模式的Node，</span></div><div class="line"><span class="comment">//(2)再判断一下队列上有没有结点，没有就创建一个空结点头，然后将Node添加到末尾，创建和添加凑采用的是AQS的CAS操作，保证可见性</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2 acquireQueued</span></div><div class="line"><span class="comment">//(1)首先判断node是不是队列第一个，如果是、且尝试获取锁成功，则将node设成head，并把此前的head.next=null，帮助gc回收</span></div><div class="line"><span class="comment">//(2)如果node不是队列第一个，或者获取锁不成功（其他线程还没释放），则进入shouldParkAfterFailedAcquire方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2.1 shouldParkAfterFailedAcquire</span></div><div class="line"><span class="comment">//(1)首次进来，waitStatus肯定为0，那么设置为SIGNAL，并立即返回false。然后返回acquireQueued方法，继续走for循环，再一次尝试获取锁，不成功继续走shouldParkAfterFailedAcquire方法，此时waitStatus=-1，因此这里直接走第一个if，返回true。</span></div><div class="line"><span class="comment">//(2)然后开始走parkAndCheckInterrupt方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * This node has already set status asking a release</span></div><div class="line"><span class="comment">         * to signal it, so it can safely park.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></div><div class="line"><span class="comment">         * indicate retry.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></div><div class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></div><div class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.2.2 parkAndCheckInterrupt</span></div><div class="line"><span class="comment">//(1)调用LockSupport的park方法阻塞住了当前的线程</span></div><div class="line"><span class="comment">//(2)至此，使用ReentrantLock让线程1独占锁、线程2进入FIFO队列并阻塞的完整流程已经整理出来了</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    setBlocker(t, blocker);</div><div class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    setBlocker(t, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="unlock流程"><a href="#unlock流程" class="headerlink" title="unlock流程"></a>unlock流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//走AQS（AbstractQueuedSynchronizer）的release流程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//先调用tryRelease尝试释放锁</span></div><div class="line"><span class="comment">//首先，只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的，调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开。</span></div><div class="line"><span class="comment">//当一条线程对同一个ReentrantLock全部解锁之后，AQS的state自然就是0了，AbstractOwnableSynchronizer的exclusiveOwnerThread将被设置为null，这样就表示没有线程占有锁，方法返回true。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div><div class="line"><span class="comment">//代码继续往下走，上面的release方法的第四行，h不为null成立，h的waitStatus为-1，不等于0也成立，所以走第5行的unparkSuccessor方法：</span></div><div class="line"><span class="comment">//s即h的下一个Node，这个Node里面的线程就是线程2，由于这个Node不等于null，所以走21行，线程2被unPark了，得以运行。</span></div><div class="line"><span class="comment">//有一个很重要的问题是：锁被解了怎样保证整个FIFO队列减少一个Node呢？这是一个很巧妙的设计，又回到了AQS的acquireQueued方法了：</span></div><div class="line"><span class="comment">//阻塞完成线程2依然会进行for循环。然后，阻塞完成了，线程2所在的Node的前驱Node是p，线程2尝试tryAcquire，成功，然后线程2就成为了head节点了，把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，h属于栈内存的内容，方法结束被自动回收，这样随着方法的调用完毕，原头Node也没有任何的引用指向它了，这样它就被GC自动回收了。此时，遇到一个return语句，acquireQueued方法结束，后面的Node也是一样的原理。</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></div><div class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></div><div class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></div><div class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></div><div class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></div><div class="line"><span class="comment">     * non-cancelled successor.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="公平锁-与-非公平锁"><a href="#公平锁-与-非公平锁" class="headerlink" title="公平锁 与 非公平锁"></a>公平锁 与 非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一上来就进入普通跟拿锁流程：加入队列中，按照lock顺序获得锁。排队，公平</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上来就拿锁，拿不再进入普通拿锁流程，插队，不公平</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/szlbm/p/5505698.html" target="_blank" rel="external">http://www.cnblogs.com/szlbm/p/5505698.html</a></p><p><a href="http://www.cnblogs.com/wanly3643/p/3835839.html" target="_blank" rel="external">http://www.cnblogs.com/wanly3643/p/3835839.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的可重入锁ReentrantLock很常见，可以用它来代替内置锁synchronized，ReentrantLock是语法级别的锁，所以比内置锁更加灵活。&lt;/p&gt;
&lt;p&gt;ReentrantLock是Java并发包中互斥锁，它有公平锁和非公平锁两种实现方式，默认构造函数采用非公平锁的方式实现。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.molingyu.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://www.molingyu.com/tags/Java/"/>
    
  </entry>
  
</feed>
