<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>前端学习笔记_JavaScript学习（一） | 子墨不语</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端学习笔记_JavaScript学习（一）</h1><a id="logo" href="/.">子墨不语</a><p class="description">路漫漫其修远兮，吾将上下而求索</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端学习笔记_JavaScript学习（一）</h1><div class="post-meta">Nov 9, 2017<span> | </span><span class="category"><a href="/categories/学习笔记/">学习笔记</a></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中的原型继承模型"><span class="toc-number">1.</span> <span class="toc-text">JavaScript中的原型继承模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-每个函数-对象-都有一个-proto-属性，指向函数的构造函数Function对象的prototype属性"><span class="toc-number">1.0.1.</span> <span class="toc-text">3. 每个函数(对象)都有一个__proto__属性，指向函数的构造函数Function对象的prototype属性:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。"><span class="toc-number">1.0.2.</span> <span class="toc-text">4. 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-instanceof-的原理"><span class="toc-number">1.0.3.</span> <span class="toc-text">5. instanceof 的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-this指针"><span class="toc-number">1.0.4.</span> <span class="toc-text">6. this指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">2.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-与-Java区别记录："><span class="toc-number"></span> <span class="toc-text">JavaScript 与 Java区别记录：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2"><span class="toc-number">2.</span> <span class="toc-text">2.</span></a></li></ol></div></div><div class="post-content"><p>技术成长栈：</p>
<ol>
<li>Android</li>
<li>Java、C/C++</li>
<li>HTML + CSS + JavaScript</li>
<li>Spring + Node.js + Vert.x</li>
<li>产品：Principle、xmind</li>
</ol>
<p>这个章节，主要记录下我的JavaScript学习中碰到的问题</p>
<h2 id="JavaScript中的原型继承模型"><a href="#JavaScript中的原型继承模型" class="headerlink" title="JavaScript中的原型继承模型"></a>JavaScript中的原型继承模型</h2><p>JavaScript中没有类似于Java、C++的类继承机制，JavaScript中的继承通过原型来实现。</p>
<p>这里的原型，我们可以类比于传统的父类，首先我们要明白:</p>
<ol>
<li>所有的对象最终原型都是Object，Object定义了JavaScript世界的通用方法和成员，这点很类似与Java</li>
<li>当访问JavaScript对象的某个成员时（成员变量或者成员函数），会首先在本对象定义中查找该成员，如果找不到就从直接父原型(<em>proto</em>)中查找，如果还找不到，就因此向上查找，直到最顶端的Object原型，如果还没有找到就报错，这便是原型链查找。</li>
<li>每个函数都有一个prototype属性，这属性指向当前函数真正所属的对象（即定义它的对象）</li>
</ol>
<p>明白了这三点，我们来看下继承的实现，实例代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//构造函数原型prototype属性定义及初始化</span></div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line"><span class="comment">//为Person函数原型prototype定义函数sayName</span></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用Person构造函数，创建person1对象</span></div><div class="line"><span class="keyword">var</span> person1 =  <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//为实例person1增加name成员，可以通过 delete person1.name;语句来删除person1的name成员</span></div><div class="line">person1.name = <span class="string">"Roket"</span>;</div><div class="line">person1.sayName();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.__proto__.name = <span class="string">"Michle"</span>;</div><div class="line"></div><div class="line">person2.sayName();</div><div class="line"></div><div class="line">alert(person1.name === person2.name);</div><div class="line"></div><div class="line">alert(person1.sayName === person2.sayName);</div></pre></td></tr></table></figure></p>
<p>上述代码中，</p>
<ul>
<li>定义了Person构造函数，并给出了空实现</li>
<li>定义Person的原型：在函数原型对象上定义name、age、job以及sayName成员</li>
<li>声明var person1、person2两个Person对象，定义的时候调用了Person的空构造函数实例化，实例化完成之后，这两个Person对象，拥有同一个原型。</li>
<li>person1在本对象内，定义了name成员，并将”Rocket”赋值给了name成员。通过chrome F12 debug工具看到， person1具有name成员，值为”Rokcet”，此时其原型person1.prototype.name的值是”Nicholas”</li>
<li>person2通过person2.__proto__ 直接访问person2的原型对象，然后将name=”Michle”赋值给原型的name成员。 通过debug看到，person2对象本身没有name成员，其原型person2.prototype.name值被修改为”Michle”，而person1.prototype.name的值也被修改为了”Michle”值。</li>
<li>根据原型链查找原理：person1.name=”Rockt”， person2.name=”Michle”，但是对于person1.sayName与person2.sayName，他们都是Person.prototype.sayName方法对象，是一个对象。</li>
</ul>
<blockquote>
<p>也就是说，JavaScript中，多个同原型实例会共享原型的所有成员，包括成员函数、成员变量，</p>
</blockquote>
<p>因此，为了解决这个问题：</p>
<ol>
<li>通常定义对象时都提供构造函数，用来初始化那些对象所私有的成员属性</li>
<li>而共享的成员、成员函数，都直接共享使用原型中的成员</li>
</ol>
<p>这便是我们所说的：组合使用 <figure class="highlight plain"><figcaption><span>和 ```原型模式```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这是ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。</div><div class="line"></div><div class="line"></div><div class="line">## JavaScript中原型继承一些重要的概念</div><div class="line"></div><div class="line">#### 1. 除了基本数据类型，所有的元素都是对象，函数Function、数组Array、对象Object</div><div class="line"></div><div class="line">Function函数、Array函数、Object函数 以及 null对象，是由JavaScript虚拟机VM内部提供的对象，是一个全局唯一的对象。</div><div class="line"></div><div class="line"></div><div class="line">#### 2. 每个对象都有一个 __proto__ 属性，指向的是创建该对象的那个函数对象(构造函数)的prototype属性</div><div class="line"></div><div class="line">```javascript</div><div class="line">//声明并定义函数对象Fn</div><div class="line">function Fn() &#123; &#125;</div><div class="line">Fn.prototype.name = &apos;name&apos;;</div><div class="line">Fn.prototype.getYear = function () &#123;</div><div class="line">    return 1998;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var fn = new Fn();</div><div class="line">console.log(fn.name);</div><div class="line">console.log(fn.getYear());</div><div class="line">console.log(fn.__proto__ === Fn.prototype);	//true</div></pre></td></tr></table></figure></p>
<p>上面代码中：</p>
<ol>
<li>对象fn由函数Fn()创建</li>
<li>Fn函数的原型 Fn.prototype具有name属性、getYear()函数</li>
<li>fn.__proto__ === Fn.prototype 为true</li>
</ol>
<p>因此，证明本节的论点，也就是说，对象继承于构造函数的prototype，也就是说，对象的原型是构造函数的prototype</p>
<h4 id="3-每个函数-对象-都有一个-proto-属性，指向函数的构造函数Function对象的prototype属性"><a href="#3-每个函数-对象-都有一个-proto-属性，指向函数的构造函数Function对象的prototype属性" class="headerlink" title="3. 每个函数(对象)都有一个__proto__属性，指向函数的构造函数Function对象的prototype属性:"></a>3. 每个函数(对象)都有一个__proto__属性，指向函数的构造函数Function对象的prototype属性:</h4><p>因为，在JavaScript世界中，函数是一个Function对象，可以通过构造函数Function(…)来创建函数，代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">"return x + y"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fn1(<span class="number">2</span>, <span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fn2(<span class="number">1</span>, <span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fn2.__proto__ === <span class="built_in">Function</span>.prototype);	<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(fn1.__proto__ === <span class="built_in">Function</span>.prototype);	<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(fn2.__proto__ === fn1.__proto__); 		<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>根据第二点，所以由Function函数创建的对象fn2的原型 fn2.__proto__ 指向的是构造函数 Function的prototype属性</p>
<h4 id="4-访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。"><a href="#4-访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。" class="headerlink" title="4. 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。"></a>4. 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</h4><p><img src="http://images.cnitblog.com/blog/138012/201409/182013450814552.png" alt=""></p>
<p>上图中，访问f1.b时，f1的基本属性中没有b，于是沿着__proto__找到了Foo.prototype.b。</p>
<p><strong><em>判断对象原型链属性的位置的方法</em></strong>：</p>
<ol>
<li>使用 hasOwnProperty 来判断对象自身是否有定义属性</li>
<li>使用 in 操作符，来确定属性是否在原型链上存在</li>
</ol>
<p>以下代码可以确定属性是存在与对象中，还是存在于原型中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, popertyName</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> !object.hasOwnProperty(popertyName) &amp;&amp; (popertyName <span class="keyword">in</span> object);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-instanceof-的原理"><a href="#5-instanceof-的原理" class="headerlink" title="5. instanceof 的原理"></a>5. instanceof 的原理</h4><ol>
<li>instanceof 是一个二元运算符： 左侧 是一个普通对象，右侧是一个函数对象 </li>
<li>instanceof 运算过程： <ol>
<li>左侧按照原型链查找，即依次追溯左侧对象的__proto__属性</li>
<li>右侧按照函数的prototype进行查找</li>
</ol>
</li>
<li>两边查找到一个相同对象的引用，则运算结束，返回true，若找不到，则返回false</li>
</ol>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * instanceof 运算符： 左边的是一个对象，右边的是一个函数</span></div><div class="line"><span class="comment"> * 1. 左边从原型链往前查找</span></div><div class="line"><span class="comment"> * 2. 右边从prototype查找</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Object是一个函数对象，它由Function构造函数创建，Object.__proto__ === Function.prototype</span></div><div class="line"><span class="comment"> * Function是一个函数对象，直接找它的prototype，即Function.prototype</span></div><div class="line"><span class="comment"> * 因此，该语句为true</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function是一个函数对象，它由Function构造函数创建，因此Function.__proto_ == Function.prototype，</span></div><div class="line"><span class="comment"> * 而Function.prototype是一个普通的Object对象，因此Function.prototype.__proto__ == Object.prototype</span></div><div class="line"><span class="comment"> * Object是一个函数对象，直接找它的prototype，即Object.prototype</span></div><div class="line"><span class="comment"> * 因此，语句为true</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function是一个函数对象，它由Function构造函数创建，因此Function.__proto_ == Function.prototype</span></div><div class="line"><span class="comment"> * Function是一个函数对象，直接找它的prototype，即Function.prototype</span></div><div class="line"><span class="comment"> * 因此，语句为true</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div></pre></td></tr></table></figure></p>
<h4 id="6-this指针"><a href="#6-this指针" class="headerlink" title="6. this指针"></a>6. this指针</h4><p>来看代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    x: <span class="number">10</span>,</div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);	<span class="comment">//此时，this是obj这个对象</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);	<span class="comment">//到这里，this指的是window</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.fn();</div></pre></td></tr></table></figure></p>
<p>这里 function f()在函数fn内部被定义，但是它是一个普通函数，它并不属于某个对象。因此它的this是window</p>
<p>再看另外一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 函数栈帧的概念：</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 在执行一个函数的时候，JavaScript会为函数做一些准备工作，创建一个栈帧，然后：</span></div><div class="line"><span class="comment"> * 1. 变量声明:</span></div><div class="line"><span class="comment"> *      1)将函数块（域）中出现的变量，声明提升到最前面来，给默认undefined值</span></div><div class="line"><span class="comment"> *      2)如果是自由变量，则往前面的栈帧查找该变量，如果最终到window栈帧都没找到，则在window栈帧默认为该变量声明，赋值undefined</span></div><div class="line"><span class="comment"> *      3)如果是函数表达式，即var fun = function(...)&#123;...&#125;，则把fun当做普通变量处理，预定义为undefined。</span></div><div class="line"><span class="comment"> * 2. this指针赋值，this可能是window、或者某个对象</span></div><div class="line"><span class="comment"> * 3. 函数声明，即直接在函数块中声明：function fun(...)&#123;...&#125;，此时，直接声明fun函数，并给它赋值，这个值就指向定义的函数。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @type &#123;number&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> outer = &#123;</div><div class="line">    x:<span class="number">10</span>,</div><div class="line">    outFun:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//对象outer</span></div><div class="line">        <span class="built_in">console</span>.log(x);     <span class="comment">//this.x 与 x的区别</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> myfun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"outer.myfun()"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> inner = &#123;</div><div class="line">            x: <span class="number">20</span>,</div><div class="line">            innerFun: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//对象obj</span></div><div class="line">                <span class="built_in">console</span>.log(x);     <span class="comment">//this.x 与 x的区别</span></div><div class="line"></div><div class="line">                <span class="comment">//为this添加myfun函数，该函数的调用需要使用obj.myfun()的方式调用</span></div><div class="line">                <span class="keyword">this</span>.myfun = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="keyword">this</span>);      <span class="comment">//对象obj</span></div><div class="line">                    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);    <span class="comment">//对象obj.x</span></div><div class="line"></div><div class="line">                    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>);      <span class="comment">//普通函数，window</span></div><div class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);    <span class="comment">//window没有x定义</span></div><div class="line">                    &#125;</div><div class="line">                    f();</div><div class="line"></div><div class="line">                &#125;;</div><div class="line">                m = <span class="number">1024</span>;</div><div class="line">                <span class="comment">//本栈中无法找到，则向前一个栈帧查找myfun()的定义</span></div><div class="line">                myfun();</div><div class="line"></div><div class="line">                <span class="keyword">var</span> fun = <span class="keyword">this</span>.myfun;</div><div class="line">                fun();</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        inner.innerFun();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">outer.outFun();</div></pre></td></tr></table></figure></p>
<p>在这里，function f()被赋值为this.now成员，在调用的时候，采用了this.now()来调用，因此，函数内部的直接this，就是这里的this，也就是obj这个对象。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> secret = <span class="string">'secret'</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">//内部对象：定义的函数</span></div><div class="line">        get_secret: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> secret;</div><div class="line">        &#125;,</div><div class="line">        new_secret: <span class="function"><span class="keyword">function</span>(<span class="params">newsecret</span>)</span>&#123;</div><div class="line">            secret = newsecret;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;();    <span class="comment">//()，直接调用该函数</span></div><div class="line"></div><div class="line"><span class="comment">//JavaScript中，内部函数作用域，永远都可以访问上层作用域的变量</span></div><div class="line"><span class="comment">//从而导致了，本不能访问var secret变量的此处，可以通过get/new_secret函数来访问</span></div><div class="line"><span class="comment">//并且成员并不会立刻被销毁，只有闭包函数被销毁了，成员secret才会被销毁。</span></div><div class="line"><span class="built_in">console</span>.log(foo.get_secret());</div><div class="line"><span class="built_in">console</span>.log(foo.secret);    <span class="comment">//error</span></div><div class="line"><span class="built_in">console</span>.log(foo.new_secret(<span class="string">'a new secret'</span>));</div><div class="line"><span class="built_in">console</span>.log(foo.get_secret());</div></pre></td></tr></table></figure>
<h1 id="JavaScript-与-Java区别记录："><a href="#JavaScript-与-Java区别记录：" class="headerlink" title="JavaScript 与 Java区别记录："></a>JavaScript 与 Java区别记录：</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2></div><div class="tags"><a href="/tags/前端/">前端</a><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a href="/2017/11/10/由DBUtils使用ResultHandler引出的一个关于JavaBean反射的问题/" class="pre">由DBUtils使用ResultHandler引出的一个关于JavaBean反射的问题</a><a href="/2017/09/27/Android启动源码阅读(三)systemserver的启动过程/" class="next">Android启动源码阅读(三)systemserver进程的启动</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.molingyu.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/源码阅读/" style="font-size: 15px;">源码阅读</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/由DBUtils使用ResultHandler引出的一个关于JavaBean反射的问题/">由DBUtils使用ResultHandler引出的一个关于JavaBean反射的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/09/前端学习笔记_JavaScript学习(一)/">前端学习笔记_JavaScript学习（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/Android启动源码阅读(三)systemserver的启动过程/">Android启动源码阅读(三)systemserver进程的启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/Android启动源码阅读(二)zygote进程的启动/">Android启动源码阅读(二)zygote进程的启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/Android启动源码阅读(一)init进程的启动/">Android启动源码阅读(一)init进程的启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/Android源码阅读技巧/">Android源码阅读准备</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/18/一个epoll实例/">一个epoll实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/17/本博客的建立/">本博客的建立</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/17/ReentrantLock/">ReentrantLock</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/JakeWharton" title="JakeWharton" target="_blank">JakeWharton</a><ul></ul><a href="https://github.com/Trinea" title="Trinea" target="_blank">Trinea</a><ul></ul><a href="http://blog.csdn.net/luoshengyang" title="罗升阳" target="_blank">罗升阳</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">子墨.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Maupassant</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>